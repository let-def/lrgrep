{
  let rec longident_to_string = function
    | Longident.Lident n -> n
    | Longident.Lapply (a, b) ->
      longident_to_string a ^ "(" ^ longident_to_string b ^ ")"
    | Longident.Ldot (a, n) ->
      longident_to_string a ^ "." ^ n

  let report_currified_constructor ?outer inner (token : Parser_raw.token) =
    let token = match token with
      | UNDERSCORE -> "_"
      | LIDENT u | UIDENT u -> u
      | LPAREN -> "..."
      | _ -> assert false
    in
    let inner_msg = longident_to_string inner ^ " (..., " ^ token ^ ")" in
    "Issue #10990: arguments of n-ary constructors should be put between parentheses, e.g. " ^
    match outer with
    | Some outer -> longident_to_string outer ^ " (" ^ inner_msg ^ ")"
    | None -> inner_msg

  let str_line pos = string_of_int pos.Lexing.pos_lnum
  let str_col pos = string_of_int (pos.Lexing.pos_cnum - pos.Lexing.pos_bol)

  let line_and_char pos = "line " ^ str_line pos ^ ", character " ^ str_col pos
}

rule error_message = parse error

| e=expr; SEMI @ ELSE
  partial {
    match e with
    | {pexp_desc = Pexp_ifthenelse(_, _, None); _} -> (
      Some ("The semicolon " ^ line_and_char $startloc(e)
            ^ " terminates the `if ... then ...` expression. \
            Remove it to add an else branch.")
      )
    | _ -> None
  }

(* A list of type parameters that is not followed by the path of a type constructore *)
(* (from "Misleading syntax error message for incorrect module definition", ocaml issue #12280) *)
| LPAREN; typs=reversed_separated_nontrivial_llist(COMMA,core_type); rp=RPAREN /atomic_type: LPAREN _ RPAREN . ...
  partial {
    match List.rev typs with
    | [] | [_] -> None
    | typs -> Some Ast_helper.(
      Printf.sprintf
        "The preceding type ending %s is incomplete.\n\
         It's missing a type constructor after the parameters, for instance: %s.\n\
         If you meant to write a tuple, use '*': %s."
        (line_and_char $endloc(rp))
        (Format.asprintf "%a" Pprintast.core_type
          (Typ.constr (Location.mknoloc (Longident.Lident "t")) typs))
        (Format.asprintf "%a" Pprintast.core_type
          (Typ.tuple typs))
    )
  }

| LIDENT / label_declaration: mutable_flag _ . COLON ... @ EQUAL
  { "Expecting ':' to declare the type of a record field, not '='" }

(* let x = 5 ; let y = 6 let z = 7 *)

| [structure_item]; semi=SEMI; [let_bindings(ext)]
  { "Might be due to the semicolon " ^ line_and_char $startloc(semi) }

| loc=_ / expr : ... . expr; [let_bindings(ext)]
  { "Expecting 'in' after let binding(s) in an expression. \n\
     This might be due to the unterminated expression at " ^
     line_and_char $endloc(loc) }

| item=structure_item; [let_bindings(ext)] @ IN
  { "A 'let ... in' is not allowed immediately after a module definition. \n\
    This can be solved by inserting ';;' or 'let () = ' after " ^ line_and_char $endloc(item) }

(* Replace builtin grammatical rule reporting unclosed parenthesis *)
| lp=LPAREN; [_* / ... . RPAREN ...]
  { "Unclosed parenthesis at " ^ line_and_char $startloc(lp) }

| pos=[_* / LET ... . IN ...]
| pos=[_* / let_bindings(ext) ... . IN ...]
| pos=[_* / let_bindings(no_ext) ... . IN ...]
  { "Expecting `in' to continue let-binding at " ^ line_and_char $startloc(pos) }

(* https://github.com/ocaml/ocaml/issues/11108
   Report when a keyword has been typed in a context where a lowercase
   identifier is expected. *)
| [_* / ... _ . LIDENT ...]
  partial { match Lexer_raw.as_keyword token with
    | None -> None
    | Some kw ->
      Some ("`" ^ kw ^ "' is a keyword and cannot appear in this context (try " ^ kw ^ "_)")
  }

(* https://github.com/ocaml/ocaml/issues/5068 *)
| [_*  / ... _ . UIDENT ... |  _* / ... _ . TYPE ... | _* / ... _ . REC ...]
  { "Expecting `type' or a module name beginning with an uppercase letter"
  }

(* https://discuss.ocaml.org/t/syntax-error-compiling-code-with-functor-module/6352 *)
| [_* / ... . seq_expr ...] @ MODULE
  {  "`module' keyword cannot appear in an expression, \
       use `(module M)' to pack a first class-module \
       or `let module M = ... in ...' to define a local module"
  }

(* https://github.com/ocaml/ocaml/issues/11445 *)

| [constructor_arguments] @ MINUSGREATER
  { "Issue #11445: in constructor arguments, \
     arrow types should be wrapped between parentheses"
  }

| outer=constr_longident; inner=constr_longident;
  [_ / pattern_gen: constr_longident pattern .]
  @ UNDERSCORE, LIDENT, UIDENT, LPAREN
  { report_currified_constructor ~outer inner token }

| constr_longident; [simple_expr]
  @ first(simple_expr)
  { (* Expliquer le raisonnement *)
    (* Plusieurs niveaux d'explications ? *)
    (* Message court identifiant la situation *)
    (* Hint pour d√©tailler. (Rappel de la syntaxe) *)
    "Application of n-ary constructors cannot be currified, \
     arguments should be wrapped between parentheses and comma separated" }

| inner=constr_longident;
  [_* / pattern_gen: constr_longident pattern .]
  @ UNDERSCORE, LIDENT, UIDENT, LPAREN
  { report_currified_constructor inner token }

| / . atomic_type @ LBRACKETATAT
  { "[@@ ...] attribute should be placed after a type (note that it attaches to the item, not to the type)" }

| / . atomic_type @ LBRACKETAT
  { "[@ ...] attribute should be placed after a type" }

(* TODO: there are many more attribute cases to handle *)

(**)

(* implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH *)
| /method_: BANG list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL . seq_expr
  { "implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /class_type_declarations: CLASS TYPE ext list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) . list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: FOR FALSE EQUAL UIDENT DOWNTO UIDENT DO UIDENT VAL *)
| [_ /expr: FOR ext list(attribute) pattern EQUAL seq_expr direction_flag seq_expr DO seq_expr . DONE]
  { "implementation: FOR FALSE EQUAL UIDENT DOWNTO UIDENT DO UIDENT VAL" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD *)
| [_ /signature_item: CLASS ext list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) . list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /method_: BANG list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type . EQUAL seq_expr]
  { "implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH *)
| /method_: list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL . seq_expr
  { "implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT METHOD *)
| [_ /class_signature: class_signature . attribute
     /class_type_declarations: CLASS TYPE ext list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature . list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT METHOD" }

(* implementation: UIDENT DOT LPAREN MODULE QUOTED_STRING_EXPR COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /simple_expr: mod_longident DOT LPAREN MODULE ext list(attribute) module_expr COLON module_type . RPAREN]
  { "implementation: UIDENT DOT LPAREN MODULE QUOTED_STRING_EXPR COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: FOR FALSE EQUAL UIDENT DOWNTO UIDENT DO WITH *)
| /expr: FOR ext list(attribute) pattern EQUAL seq_expr direction_flag seq_expr DO . seq_expr DONE
  { "implementation: FOR FALSE EQUAL UIDENT DOWNTO UIDENT DO WITH" }

(* implementation: TYPE NONREC LIDENT PLUSEQ FALSE COLON QUOTED_STRING_EXPR CONSTRAINT *)
| [_ /reversed_bar_llist(extension_constructor): reversed_bar_llist(extension_constructor) . generic_constructor_declaration(BAR)
     /reversed_bar_llist(extension_constructor): reversed_bar_llist(extension_constructor) . extension_constructor_rebind(BAR)
     /structure_item: TYPE ext list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) . list(post_item_attribute)]
  { "implementation: TYPE NONREC LIDENT PLUSEQ FALSE COLON QUOTED_STRING_EXPR CONSTRAINT" }

(* interface: TYPE NONREC LIDENT COLONEQUAL FALSE LET *)
| [_ /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) NONREC type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) . list(post_item_attribute)
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) . CONSTRAINT core_type EQUAL core_type]
  { "interface: TYPE NONREC LIDENT COLONEQUAL FALSE LET" }

(* interface: TYPE NONREC LIDENT PLUSEQ FALSE CONSTRAINT *)
| [_ /reversed_bar_llist(extension_constructor_declaration): reversed_bar_llist(extension_constructor_declaration) . generic_constructor_declaration(BAR)
     /signature_item: TYPE ext list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) . list(post_item_attribute)]
  { "interface: TYPE NONREC LIDENT PLUSEQ FALSE CONSTRAINT" }

(* implementation: TYPE NONREC LIDENT EQUAL DOTDOT WITH *)
| [_ /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) . list(post_item_attribute)
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) . CONSTRAINT core_type EQUAL core_type]
  { "implementation: TYPE NONREC LIDENT EQUAL DOTDOT WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR RPAREN *)
| [_ /signature_item: CLASS ext list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type . list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR RPAREN" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(and_class_description): AND list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) . list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT DOT WITH *)
| /method_: BANG list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT . core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT DOT WITH" }

(* implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /method_: list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type . EQUAL seq_expr]
  { "implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /structure_item: CLASS ext list(attribute) virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) . list(and_class_declaration)]
  { "implementation: CLASS LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: CLASS TYPE LIDENT EQUAL WITH *)
| /class_type_declarations: CLASS TYPE ext list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL . class_signature list(post_item_attribute) list(and_class_type_declaration)
  { "implementation: CLASS TYPE LIDENT EQUAL WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(and_class_type_declaration): AND list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) . list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: UIDENT DOT LPAREN MODULE QUOTED_STRING_EXPR COLON WITH *)
| /simple_expr: mod_longident DOT LPAREN MODULE ext list(attribute) module_expr COLON . module_type RPAREN
  { "implementation: UIDENT DOT LPAREN MODULE QUOTED_STRING_EXPR COLON WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LPAREN UIDENT RPAREN LESSMINUS WITH *)
| /expr: simple_expr DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS . expr
  { "implementation: FALSE DOT UIDENT DOTOP LPAREN UIDENT RPAREN LESSMINUS WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LBRACKET UIDENT RBRACKET LESSMINUS WITH *)
| /expr: simple_expr DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS . expr
  { "implementation: FALSE DOT UIDENT DOTOP LBRACKET UIDENT RBRACKET LESSMINUS WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LBRACE UIDENT RBRACE LESSMINUS WITH *)
| /expr: simple_expr DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS . expr
  { "implementation: FALSE DOT UIDENT DOTOP LBRACE UIDENT RBRACE LESSMINUS WITH" }

(* implementation: FOR FALSE EQUAL UIDENT DOWNTO UIDENT VAL *)
| [_ /expr: FOR ext list(attribute) pattern EQUAL seq_expr direction_flag seq_expr . DO seq_expr DONE]
  { "implementation: FOR FALSE EQUAL UIDENT DOWNTO UIDENT VAL" }

(* implementation: LET EXCEPTION FALSE IN WITH *)
| /expr: LET EXCEPTION ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) IN . seq_expr
  { "implementation: LET EXCEPTION FALSE IN WITH" }

(* implementation: INCLUDE LPAREN VAL UIDENT COLON QUOTED_STRING_EXPR COLONGREATER QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /paren_module_expr: LPAREN VAL list(attribute) expr COLON module_type COLONGREATER module_type . RPAREN]
  { "implementation: INCLUDE LPAREN VAL UIDENT COLON QUOTED_STRING_EXPR COLONGREATER QUOTED_STRING_EXPR WHILE" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD *)
| [_ /signature_item: MODULE ext list(attribute) REC module_name COLON module_type list(post_item_attribute) . list(and_module_declaration)]
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT COLONEQUAL FALSE LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(generic_and_type_declaration(type_subst_kind)): AND list(attribute) type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) . list(generic_and_type_declaration(type_subst_kind))]
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT COLONEQUAL FALSE LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: TYPE NONREC LIDENT PLUSEQ PRIVATE WITH *)
| [_ /structure_item: TYPE ext list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag . reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE NONREC LIDENT PLUSEQ PRIVATE WITH" }

(* implementation: TYPE LIDENT PLUSEQ FALSE COLON QUOTED_STRING_EXPR CONSTRAINT *)
| [_ /reversed_bar_llist(extension_constructor): reversed_bar_llist(extension_constructor) . generic_constructor_declaration(BAR)
     /reversed_bar_llist(extension_constructor): reversed_bar_llist(extension_constructor) . extension_constructor_rebind(BAR)
     /structure_item: TYPE ext list(attribute) type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) . list(post_item_attribute)]
  { "implementation: TYPE LIDENT PLUSEQ FALSE COLON QUOTED_STRING_EXPR CONSTRAINT" }

(* interface: TYPE NONREC LIDENT PLUSEQ PRIVATE WITH *)
| [_ /signature_item: TYPE ext list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag . reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE NONREC LIDENT PLUSEQ PRIVATE WITH" }

(* interface: TYPE LIDENT COLONEQUAL FALSE LET *)
| [_ /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) . list(post_item_attribute)
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) . CONSTRAINT core_type EQUAL core_type]
  { "interface: TYPE LIDENT COLONEQUAL FALSE LET" }

(* interface: TYPE LIDENT PLUSEQ FALSE CONSTRAINT *)
| [_ /reversed_bar_llist(extension_constructor_declaration): reversed_bar_llist(extension_constructor_declaration) . generic_constructor_declaration(BAR)
     /signature_item: TYPE ext list(attribute) type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) . list(post_item_attribute)]
  { "interface: TYPE LIDENT PLUSEQ FALSE CONSTRAINT" }

(* interface: CLASS LIDENT COLON WITH *)
| /signature_item: CLASS ext list(attribute) virtual_flag formal_class_parameters LIDENT COLON . class_type list(post_item_attribute) list(and_class_description)
  { "interface: CLASS LIDENT COLON WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT COLON QUOTED_STRING_EXPR RPAREN *)
| [_ /list(and_class_description): AND list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type . list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT COLON QUOTED_STRING_EXPR RPAREN" }

(* implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT RPAREN *)
| [_ /method_: BANG list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) . DOT core_type EQUAL seq_expr]
  { "implementation: OBJECT METHOD BANG LIDENT COLON TYPE LIDENT RPAREN" }

(* implementation: OBJECT METHOD BANG LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /method_: BANG list(attribute) private_flag LIDENT COLON possibly_poly(core_type) EQUAL . seq_expr
  { "implementation: OBJECT METHOD BANG LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT DOT WITH *)
| /method_: list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT . core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT DOT WITH" }

(* implementation: OBJECT INHERIT LET OPEN BANG UIDENT IN QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: LET OPEN BANG list(attribute) mod_longident IN class_expr .
     /class_expr: class_expr . attribute]
  { "implementation: OBJECT INHERIT LET OPEN BANG UIDENT IN QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT EQUAL LIDENT AND LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(and_class_declaration): AND list(attribute) virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) . list(and_class_declaration)]
  { "implementation: CLASS LIDENT EQUAL LIDENT AND LIDENT EQUAL LIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: CLASS TYPE LIDENT WITH *)
| /class_type_declarations: CLASS TYPE ext list(attribute) virtual_flag formal_class_parameters LIDENT . EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)
  { "implementation: CLASS TYPE LIDENT WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT EQUAL LIDENT METHOD *)
| [_ /class_signature: class_signature . attribute
     /list(and_class_type_declaration): AND list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature . list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT EQUAL LIDENT METHOD" }

(* implementation: LET OPEN BANG QUOTED_STRING_EXPR IN WITH *)
| /expr: LET OPEN BANG ext list(attribute) module_expr IN . seq_expr
  { "implementation: LET OPEN BANG QUOTED_STRING_EXPR IN WITH" }

(* implementation: UIDENT DOT LPAREN MODULE QUOTED_STRING_EXPR WITH *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /simple_expr: mod_longident DOT LPAREN MODULE ext list(attribute) module_expr . COLON module_type RPAREN]
  { "implementation: UIDENT DOT LPAREN MODULE QUOTED_STRING_EXPR WITH" }

(* implementation: FUN LPAREN TYPE LIDENT RPAREN WITH *)
| /expr: FUN ext list(attribute) LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN . fun_def
  { "implementation: FUN LPAREN TYPE LIDENT RPAREN WITH" }

(* implementation: LET LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH *)
| /let_binding_body_no_punning: val_ident COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL . seq_expr
  { "implementation: LET LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: FOR FALSE EQUAL UIDENT DOWNTO WITH *)
| [_ /expr: FOR ext list(attribute) pattern EQUAL seq_expr direction_flag . seq_expr DO seq_expr DONE]
  { "implementation: FOR FALSE EQUAL UIDENT DOWNTO WITH" }

(* implementation: IF UIDENT THEN UIDENT ELSE WITH *)
| /expr: IF ext list(attribute) seq_expr THEN expr ELSE . expr
  { "implementation: IF UIDENT THEN UIDENT ELSE WITH" }

(* implementation: LET MODULE UIDENT EQUAL QUOTED_STRING_EXPR IN WITH *)
| /expr: LET MODULE ext list(attribute) module_name module_binding_body IN . seq_expr
  { "implementation: LET MODULE UIDENT EQUAL QUOTED_STRING_EXPR IN WITH" }

(* implementation: LET EXCEPTION FALSE LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: LET EXCEPTION ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) . IN seq_expr]
  { "implementation: LET EXCEPTION FALSE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: INCLUDE LPAREN VAL UIDENT COLON QUOTED_STRING_EXPR COLONGREATER WITH *)
| /paren_module_expr: LPAREN VAL list(attribute) expr COLON module_type COLONGREATER . module_type RPAREN
  { "implementation: INCLUDE LPAREN VAL UIDENT COLON QUOTED_STRING_EXPR COLONGREATER WITH" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD *)
| [_ /structure_item: MODULE ext list(attribute) REC module_name module_binding_body list(post_item_attribute) . list(and_module_binding)]
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: EXTERNAL LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /primitive_declaration: EXTERNAL ext list(attribute) val_ident COLON core_type EQUAL . nonempty_list(raw_string) list(post_item_attribute)
  { "implementation: EXTERNAL LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: EXCEPTION FALSE EQUAL UIDENT LBRACKETAT AND RBRACKET WHILE *)
| [_ /str_exception_declaration: EXCEPTION ext list(attribute) constr_ident EQUAL constr_longident list(attribute) . list(post_item_attribute)]
  { "implementation: EXCEPTION FALSE EQUAL UIDENT LBRACKETAT AND RBRACKET WHILE" }

(* interface: MODULE TYPE LIDENT COLONEQUAL QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /module_type_subst: MODULE TYPE ext list(attribute) ident COLONEQUAL module_type . list(post_item_attribute)]
  { "interface: MODULE TYPE LIDENT COLONEQUAL QUOTED_STRING_EXPR WHILE" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /signature_item: MODULE ext list(attribute) REC module_name COLON module_type . list(post_item_attribute) list(and_module_declaration)]
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: TYPE LIDENT AND LIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(generic_and_type_declaration(type_kind)): AND list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) . list(generic_and_type_declaration(type_kind))]
  { "implementation: TYPE LIDENT AND LIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT COLONEQUAL FALSE LET *)
| [_ /list(generic_and_type_declaration(type_subst_kind)): AND list(attribute) type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) . list(post_item_attribute) list(generic_and_type_declaration(type_subst_kind))
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) . CONSTRAINT core_type EQUAL core_type]
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT COLONEQUAL FALSE LET" }

(* parse_pattern: LPAREN MODULE UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /simple_pattern_not_ident: LPAREN MODULE ext list(attribute) module_name COLON module_type . RPAREN]
  { "parse_pattern: LPAREN MODULE UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: LPAREN MODULE QUOTED_STRING_EXPR COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /simple_expr: LPAREN MODULE ext list(attribute) module_expr COLON module_type . RPAREN]
  { "implementation: LPAREN MODULE QUOTED_STRING_EXPR COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: TYPE NONREC LIDENT PLUSEQ WITH *)
| /structure_item: TYPE ext list(attribute) NONREC type_parameters type_longident PLUSEQ . private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
  { "implementation: TYPE NONREC LIDENT PLUSEQ WITH" }

(* implementation: TYPE LIDENT EQUAL DOTDOT WITH *)
| [_ /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) . list(post_item_attribute)
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) . CONSTRAINT core_type EQUAL core_type]
  { "implementation: TYPE LIDENT EQUAL DOTDOT WITH" }

(* implementation: TYPE LIDENT PLUSEQ PRIVATE WITH *)
| [_ /structure_item: TYPE ext list(attribute) type_parameters type_longident PLUSEQ private_flag . reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE LIDENT PLUSEQ PRIVATE WITH" }

(* interface: TYPE NONREC LIDENT COLONEQUAL WITH *)
| /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) NONREC type_parameters LIDENT COLONEQUAL . nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  { "interface: TYPE NONREC LIDENT COLONEQUAL WITH" }

(* interface: TYPE NONREC LIDENT PLUSEQ WITH *)
| /signature_item: TYPE ext list(attribute) NONREC type_parameters type_longident PLUSEQ . private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
  { "interface: TYPE NONREC LIDENT PLUSEQ WITH" }

(* interface: TYPE LIDENT PLUSEQ PRIVATE WITH *)
| [_ /signature_item: TYPE ext list(attribute) type_parameters type_longident PLUSEQ private_flag . reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE LIDENT PLUSEQ PRIVATE WITH" }

(* interface: TYPE NONREC LIDENT WITH *)
| /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) NONREC type_parameters LIDENT . COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC type_parameters LIDENT . type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "interface: TYPE NONREC LIDENT WITH" }

(* implementation: TYPE NONREC LIDENT WITH *)
| /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC type_parameters LIDENT . type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "implementation: TYPE NONREC LIDENT WITH" }

(* interface: CLASS LIDENT WITH *)
| /signature_item: CLASS ext list(attribute) virtual_flag formal_class_parameters LIDENT . COLON class_type list(post_item_attribute) list(and_class_description)
  { "interface: CLASS LIDENT WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT COLON WITH *)
| /list(and_class_description): AND list(attribute) virtual_flag formal_class_parameters LIDENT COLON . class_type list(post_item_attribute) list(and_class_description)
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT COLON WITH" }

(* implementation: CLASS LIDENT WITH *)
| /structure_item: CLASS ext list(attribute) virtual_flag formal_class_parameters LIDENT . class_fun_binding list(post_item_attribute) list(and_class_declaration)
  { "implementation: CLASS LIDENT WITH" }

(* implementation: OBJECT VAL BANG LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /value: BANG list(attribute) mutable_flag LIDENT type_constraint EQUAL . seq_expr
  { "implementation: OBJECT VAL BANG LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: OBJECT METHOD BANG LIDENT COLON TYPE WITH *)
| /method_: BANG list(attribute) private_flag LIDENT COLON TYPE . nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD BANG LIDENT COLON TYPE WITH" }

(* implementation: OBJECT METHOD BANG LIDENT COLON QUOTED_STRING_EXPR VAL *)
| [_ /method_: BANG list(attribute) private_flag LIDENT COLON possibly_poly(core_type) . EQUAL seq_expr]
  { "implementation: OBJECT METHOD BANG LIDENT COLON QUOTED_STRING_EXPR VAL" }

(* implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT RPAREN *)
| [_ /method_: list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) . DOT core_type EQUAL seq_expr]
  { "implementation: OBJECT METHOD LIDENT COLON TYPE LIDENT RPAREN" }

(* implementation: OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /method_: list(attribute) private_flag LIDENT COLON possibly_poly(core_type) EQUAL . seq_expr
  { "implementation: OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: OBJECT INHERIT LET PERCENT AND LIDENT VAL *)
| [_ /let_bindings(no_ext): LET PERCENT attr_id list(attribute) rec_flag let_binding_body . list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET PERCENT AND LIDENT VAL" }

(* implementation: OBJECT INHERIT LET OPEN BANG UIDENT IN WITH *)
| /class_expr: LET OPEN BANG list(attribute) mod_longident IN . class_expr
  { "implementation: OBJECT INHERIT LET OPEN BANG UIDENT IN WITH" }

(* implementation: OBJECT INHERIT LET OPEN UIDENT IN QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: LET OPEN list(attribute) mod_longident IN class_expr .
     /class_expr: class_expr . attribute]
  { "implementation: OBJECT INHERIT LET OPEN UIDENT IN QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS TYPE LBRACKET UNDERSCORE RBRACKET WITH *)
| [_ /class_type_declarations: CLASS TYPE ext list(attribute) virtual_flag formal_class_parameters . LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LBRACKET UNDERSCORE RBRACKET WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /class_sig_field: VAL list(attribute) mutable_virtual_flags LIDENT COLON core_type . list(post_item_attribute)
     /core_type: core_type . attribute]
  { "implementation: CLASS LIDENT COLON OBJECT VAL LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR INITIALIZER *)
| [_ /class_sig_field: METHOD list(attribute) private_virtual_flags LIDENT COLON possibly_poly(core_type) . list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR INITIALIZER" }

(* implementation: CLASS LIDENT COLON LET OPEN BANG UIDENT IN WITH *)
| /class_signature: LET OPEN BANG list(attribute) mod_longident IN . class_signature
  { "implementation: CLASS LIDENT COLON LET OPEN BANG UIDENT IN WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT EQUAL WITH *)
| /list(and_class_type_declaration): AND list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL . class_signature list(post_item_attribute) list(and_class_type_declaration)
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT EQUAL WITH" }

(* parse_pattern: LPAREN MODULE UIDENT COLON WITH *)
| /simple_pattern_not_ident: LPAREN MODULE ext list(attribute) module_name COLON . module_type RPAREN
  { "parse_pattern: LPAREN MODULE UIDENT COLON WITH" }

(* implementation: LET OPEN BANG QUOTED_STRING_EXPR WITH *)
| [_ /expr: LET OPEN BANG ext list(attribute) module_expr . IN seq_expr
     /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN]
  { "implementation: LET OPEN BANG QUOTED_STRING_EXPR WITH" }

(* implementation: UIDENT DOT LPAREN MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /simple_expr: mod_longident DOT LPAREN MODULE ext list(attribute) . module_expr COLON module_type RPAREN]
  { "implementation: UIDENT DOT LPAREN MODULE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: FUN LPAREN TYPE LIDENT DOT *)
| [_ /expr: FUN ext list(attribute) LPAREN TYPE nonempty_list(mkrhs(LIDENT)) . RPAREN fun_def]
  { "implementation: FUN LPAREN TYPE LIDENT DOT" }

(* implementation: LET LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /let_binding_body_no_punning: val_ident COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type . EQUAL seq_expr]
  { "implementation: LET LIDENT COLON TYPE LIDENT DOT QUOTED_STRING_EXPR WITH" }

(* implementation: LET LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH *)
| /let_binding_body_no_punning: val_ident COLON reversed_nonempty_llist(typevar) DOT core_type EQUAL . seq_expr
  { "implementation: LET LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP LPAREN UIDENT RBRACKET *)
| [_ /simple_expr: simple_expr DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) . RPAREN]
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP LPAREN UIDENT RBRACKET" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACKET UIDENT RPAREN *)
| [_ /simple_expr: simple_expr DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET]
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACKET UIDENT RPAREN" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACE UIDENT RPAREN *)
| [_ /simple_expr: simple_expr DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) . RBRACE]
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACE UIDENT RPAREN" }

(* implementation: UIDENT DOTOP LPAREN UIDENT RPAREN LESSMINUS WITH *)
| /expr: simple_expr DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS . expr
  { "implementation: UIDENT DOTOP LPAREN UIDENT RPAREN LESSMINUS WITH" }

(* implementation: UIDENT DOTOP LBRACKET UIDENT RBRACKET LESSMINUS WITH *)
| /expr: simple_expr DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS . expr
  { "implementation: UIDENT DOTOP LBRACKET UIDENT RBRACKET LESSMINUS WITH" }

(* implementation: UIDENT DOTOP LBRACE UIDENT RBRACE LESSMINUS WITH *)
| /expr: simple_expr DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS . expr
  { "implementation: UIDENT DOTOP LBRACE UIDENT RBRACE LESSMINUS WITH" }

(* implementation: FALSE DOT LPAREN UIDENT RPAREN LESSMINUS WITH *)
| /expr: simple_expr DOT LPAREN seq_expr RPAREN LESSMINUS . expr
  { "implementation: FALSE DOT LPAREN UIDENT RPAREN LESSMINUS WITH" }

(* implementation: FALSE DOT LBRACKET UIDENT RBRACKET LESSMINUS WITH *)
| /expr: simple_expr DOT LBRACKET seq_expr RBRACKET LESSMINUS . expr
  { "implementation: FALSE DOT LBRACKET UIDENT RBRACKET LESSMINUS WITH" }

(* implementation: FALSE DOT LBRACE UIDENT RBRACE LESSMINUS WITH *)
| /expr: simple_expr DOT LBRACE seq_expr RBRACE LESSMINUS . expr
  { "implementation: FALSE DOT LBRACE UIDENT RBRACE LESSMINUS WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LPAREN UIDENT RBRACKET *)
| [_ /expr: simple_expr DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) . RPAREN LESSMINUS expr
     /simple_expr: simple_expr DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) . RPAREN]
  { "implementation: FALSE DOT UIDENT DOTOP LPAREN UIDENT RBRACKET" }

(* implementation: FALSE DOT UIDENT DOTOP LBRACKET UIDENT RPAREN *)
| [_ /expr: simple_expr DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET LESSMINUS expr
     /simple_expr: simple_expr DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET]
  { "implementation: FALSE DOT UIDENT DOTOP LBRACKET UIDENT RPAREN" }

(* implementation: FALSE DOT UIDENT DOTOP LBRACE UIDENT RPAREN *)
| [_ /expr: simple_expr DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) . RBRACE LESSMINUS expr
     /simple_expr: simple_expr DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) . RBRACE]
  { "implementation: FALSE DOT UIDENT DOTOP LBRACE UIDENT RPAREN" }

(* implementation: FOR FALSE EQUAL UIDENT VAL *)
| [_ /expr: FOR ext list(attribute) pattern EQUAL seq_expr . direction_flag seq_expr DO seq_expr DONE]
  { "implementation: FOR FALSE EQUAL UIDENT VAL" }

(* implementation: LET OPEN QUOTED_STRING_EXPR IN WITH *)
| /expr: LET OPEN ext list(attribute) module_expr IN . seq_expr
  { "implementation: LET OPEN QUOTED_STRING_EXPR IN WITH" }

(* implementation: LET MODULE UIDENT EQUAL QUOTED_STRING_EXPR VAL *)
| [_ /expr: LET MODULE ext list(attribute) module_name module_binding_body . IN seq_expr]
  { "implementation: LET MODULE UIDENT EQUAL QUOTED_STRING_EXPR VAL" }

(* implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR SEMI WITH *)
| /label_declaration_semi: mutable_flag LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) SEMI . list(attribute)
  { "implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR SEMI WITH" }

(* implementation: LET EXCEPTION FALSE COLON QUOTED_STRING_EXPR VAL *)
| [_ /expr: LET EXCEPTION ext list(attribute) constr_ident generalized_constructor_arguments . list(attribute) IN seq_expr]
  { "implementation: LET EXCEPTION FALSE COLON QUOTED_STRING_EXPR VAL" }

(* implementation: INCLUDE LPAREN VAL UIDENT COLONGREATER QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /paren_module_expr: LPAREN VAL list(attribute) expr COLONGREATER module_type . RPAREN]
  { "implementation: INCLUDE LPAREN VAL UIDENT COLONGREATER QUOTED_STRING_EXPR WHILE" }

(* implementation: INCLUDE LPAREN VAL UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /paren_module_expr: LPAREN VAL list(attribute) expr COLON module_type . RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) expr COLON module_type . COLONGREATER module_type RPAREN]
  { "implementation: INCLUDE LPAREN VAL UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR IN *)
| [_ /structure_item: MODULE ext list(attribute) REC module_name module_binding_body . list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR IN" }

(* implementation: EXTERNAL LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /primitive_declaration: EXTERNAL ext list(attribute) val_ident COLON core_type . EQUAL nonempty_list(raw_string) list(post_item_attribute)]
  { "implementation: EXTERNAL LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: EXCEPTION FALSE EQUAL UIDENT BAR *)
| [_ /str_exception_declaration: EXCEPTION ext list(attribute) constr_ident EQUAL constr_longident . list(attribute) list(post_item_attribute)]
  { "implementation: EXCEPTION FALSE EQUAL UIDENT BAR" }

(* implementation: EXCEPTION FALSE LBRACKETAT AND RBRACKET WHILE *)
| [_ /sig_exception_declaration: EXCEPTION ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) . list(post_item_attribute)]
  { "implementation: EXCEPTION FALSE LBRACKETAT AND RBRACKET WHILE" }

(* interface: MODULE TYPE LIDENT COLONEQUAL WITH *)
| /module_type_subst: MODULE TYPE ext list(attribute) ident COLONEQUAL . module_type list(post_item_attribute)
  { "interface: MODULE TYPE LIDENT COLONEQUAL WITH" }

(* interface: MODULE UIDENT COLONEQUAL UIDENT WITH *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN
     /module_subst: MODULE ext list(attribute) UIDENT COLONEQUAL mod_ext_longident . list(post_item_attribute)]
  { "interface: MODULE UIDENT COLONEQUAL UIDENT WITH" }

(* interface: MODULE REC UIDENT COLON WITH *)
| /signature_item: MODULE ext list(attribute) REC module_name COLON . module_type list(post_item_attribute) list(and_module_declaration)
  { "interface: MODULE REC UIDENT COLON WITH" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(and_module_declaration): AND list(attribute) module_name COLON module_type list(post_item_attribute) . list(and_module_declaration)]
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT COLON QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD" }

(* interface: MODULE UIDENT EQUAL UIDENT WITH *)
| [_ /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /signature_item: MODULE ext list(attribute) module_name EQUAL mod_longident . list(post_item_attribute)]
  { "interface: MODULE UIDENT EQUAL UIDENT WITH" }

(* implementation: TYPE LIDENT AND LIDENT EQUAL DOTDOT WITH *)
| [_ /list(generic_and_type_declaration(type_kind)): AND list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) . list(post_item_attribute) list(generic_and_type_declaration(type_kind))
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) . CONSTRAINT core_type EQUAL core_type]
  { "implementation: TYPE LIDENT AND LIDENT EQUAL DOTDOT WITH" }

(* implementation: LPAREN MODULE QUOTED_STRING_EXPR COLON WITH *)
| /simple_expr: LPAREN MODULE ext list(attribute) module_expr COLON . module_type RPAREN
  { "implementation: LPAREN MODULE QUOTED_STRING_EXPR COLON WITH" }

(* implementation: TYPE NONREC UIDENT DOT LIDENT WHILE *)
| [_ /structure_item: TYPE ext list(attribute) NONREC type_parameters type_longident . PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE NONREC UIDENT DOT LIDENT WHILE" }

(* implementation: TYPE LIDENT PLUSEQ WITH *)
| /structure_item: TYPE ext list(attribute) type_parameters type_longident PLUSEQ . private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
  { "implementation: TYPE LIDENT PLUSEQ WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR SEMI LBRACKETAT AND RBRACKET WHILE *)
| [_ /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute) . meth_list
     /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute) .]
  { "parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR SEMI LBRACKETAT AND RBRACKET WHILE" }

(* interface: TYPE NONREC UIDENT DOT LIDENT WHILE *)
| [_ /signature_item: TYPE ext list(attribute) NONREC type_parameters type_longident . PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE NONREC UIDENT DOT LIDENT WHILE" }

(* interface: TYPE LIDENT COLONEQUAL WITH *)
| /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) type_parameters LIDENT COLONEQUAL . nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  { "interface: TYPE LIDENT COLONEQUAL WITH" }

(* interface: TYPE LIDENT PLUSEQ WITH *)
| /signature_item: TYPE ext list(attribute) type_parameters type_longident PLUSEQ . private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
  { "interface: TYPE LIDENT PLUSEQ WITH" }

(* implementation: VAL LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /value_description: VAL ext list(attribute) val_ident COLON core_type . list(post_item_attribute)]
  { "implementation: VAL LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: WHILE UIDENT DO UIDENT VAL *)
| [_ /expr: WHILE ext list(attribute) seq_expr DO seq_expr . DONE]
  { "implementation: WHILE UIDENT DO UIDENT VAL" }

(* implementation: VAL LIDENT COLON WITH *)
| /value_description: VAL ext list(attribute) val_ident COLON . core_type list(post_item_attribute)
  { "implementation: VAL LIDENT COLON WITH" }

(* interface: TYPE NONREC UNDERSCORE WITH *)
| [_ /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) NONREC type_parameters . LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC type_parameters . LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /signature_item: TYPE ext list(attribute) NONREC type_parameters . type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE NONREC UNDERSCORE WITH" }

(* implementation: TYPE NONREC UNDERSCORE WITH *)
| [_ /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC type_parameters . LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /structure_item: TYPE ext list(attribute) NONREC type_parameters . type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE NONREC UNDERSCORE WITH" }

(* interface: CLASS LBRACKET UNDERSCORE RBRACKET WITH *)
| [_ /signature_item: CLASS ext list(attribute) virtual_flag formal_class_parameters . LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LBRACKET UNDERSCORE RBRACKET WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT WITH *)
| /list(and_class_description): AND list(attribute) virtual_flag formal_class_parameters LIDENT . COLON class_type list(post_item_attribute) list(and_class_description)
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LIDENT WITH" }

(* implementation: CLASS LBRACKET UNDERSCORE RBRACKET WITH *)
| [_ /structure_item: CLASS ext list(attribute) virtual_flag formal_class_parameters . LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS LBRACKET UNDERSCORE RBRACKET WITH" }

(* implementation: OBJECT VAL BANG LIDENT EQUAL WITH *)
| /value: BANG list(attribute) mutable_flag LIDENT EQUAL . seq_expr
  { "implementation: OBJECT VAL BANG LIDENT EQUAL WITH" }

(* implementation: OBJECT VAL BANG LIDENT COLON QUOTED_STRING_EXPR RBRACE *)
| [_ /value: BANG list(attribute) mutable_flag LIDENT type_constraint . EQUAL seq_expr]
  { "implementation: OBJECT VAL BANG LIDENT COLON QUOTED_STRING_EXPR RBRACE" }

(* implementation: OBJECT VAL LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /value: list(attribute) mutable_flag LIDENT type_constraint EQUAL . seq_expr
  { "implementation: OBJECT VAL LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: OBJECT METHOD BANG LIDENT COLON WITH *)
| /method_: BANG list(attribute) private_flag LIDENT COLON . possibly_poly(core_type) EQUAL seq_expr
  /method_: BANG list(attribute) private_flag LIDENT COLON . TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD BANG LIDENT COLON WITH" }

(* implementation: OBJECT METHOD LIDENT COLON TYPE WITH *)
| /method_: list(attribute) private_flag LIDENT COLON TYPE . nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD LIDENT COLON TYPE WITH" }

(* implementation: OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR VAL *)
| [_ /method_: list(attribute) private_flag LIDENT COLON possibly_poly(core_type) . EQUAL seq_expr]
  { "implementation: OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR VAL" }

(* implementation: OBJECT INHERIT LET PERCENT AND REC WITH *)
| [_ /let_bindings(no_ext): LET PERCENT attr_id list(attribute) rec_flag . let_binding_body list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET PERCENT AND REC WITH" }

(* implementation: OBJECT INHERIT LET OPEN BANG UIDENT WITH *)
| [_ /class_expr: LET OPEN BANG list(attribute) mod_longident . IN class_expr
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT]
  { "implementation: OBJECT INHERIT LET OPEN BANG UIDENT WITH" }

(* implementation: OBJECT INHERIT LET OPEN UIDENT IN WITH *)
| /class_expr: LET OPEN list(attribute) mod_longident IN . class_expr
  { "implementation: OBJECT INHERIT LET OPEN UIDENT IN WITH" }

(* implementation: OBJECT INHERIT BANG LIDENT AS LIDENT WITH *)
| [_ /class_field: INHERIT BANG list(attribute) class_expr option(preceded(AS,mkrhs(LIDENT))) . list(post_item_attribute)]
  { "implementation: OBJECT INHERIT BANG LIDENT AS LIDENT WITH" }

(* implementation: CLASS LIDENT EQUAL LIDENT AND LIDENT WITH *)
| /list(and_class_declaration): AND list(attribute) virtual_flag formal_class_parameters LIDENT . class_fun_binding list(post_item_attribute) list(and_class_declaration)
  { "implementation: CLASS LIDENT EQUAL LIDENT AND LIDENT WITH" }

(* implementation: CLASS TYPE VIRTUAL WITH *)
| [_ /class_type_declarations: CLASS TYPE ext list(attribute) virtual_flag . formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE VIRTUAL WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL LIDENT COLON WITH *)
| /class_sig_field: VAL list(attribute) mutable_virtual_flags LIDENT COLON . core_type list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT VAL LIDENT COLON WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD LIDENT COLON WITH *)
| /class_sig_field: METHOD list(attribute) private_virtual_flags LIDENT COLON . possibly_poly(core_type) list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT METHOD LIDENT COLON WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN BANG UIDENT WITH *)
| [_ /class_signature: LET OPEN BANG list(attribute) mod_longident . IN class_signature
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT]
  { "implementation: CLASS LIDENT COLON LET OPEN BANG UIDENT WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN UIDENT IN WITH *)
| /class_signature: LET OPEN list(attribute) mod_longident IN . class_signature
  { "implementation: CLASS LIDENT COLON LET OPEN UIDENT IN WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT WITH *)
| /list(and_class_type_declaration): AND list(attribute) virtual_flag formal_class_parameters LIDENT . EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LIDENT WITH" }

(* parse_pattern: LPAREN MODULE UIDENT WITH *)
| [_ /simple_pattern_not_ident: LPAREN MODULE ext list(attribute) module_name . RPAREN
     /simple_pattern_not_ident: LPAREN MODULE ext list(attribute) module_name . COLON module_type RPAREN]
  { "parse_pattern: LPAREN MODULE UIDENT WITH" }

(* parse_core_type: LBRACKETLESS QUOTED_STRING_EXPR GREATER BACKQUOTE LIDENT WITH *)
| [_ /atomic_type: LBRACKETLESS option(BAR) reversed_separated_nonempty_llist(BAR,row_field) GREATER reversed_nonempty_llist(name_tag) . RBRACKET
     /reversed_nonempty_llist(name_tag): reversed_nonempty_llist(name_tag) . name_tag]
  { "parse_core_type: LBRACKETLESS QUOTED_STRING_EXPR GREATER BACKQUOTE LIDENT WITH" }

(* parse_pattern: FALSE LPAREN TYPE LIDENT RPAREN WITH *)
| /pattern_gen: constr_longident LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN . simple_pattern
  { "parse_pattern: FALSE LPAREN TYPE LIDENT RPAREN WITH" }

(* parse_pattern: LBRACE LIDENT SEMI UNDERSCORE WITH *)
| /listx(SEMI,record_pat_field,UNDERSCORE): label_longident option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI UNDERSCORE . option(SEMI)
  { "parse_pattern: LBRACE LIDENT SEMI UNDERSCORE WITH" }

(* implementation: LET OPEN BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: LET OPEN BANG ext list(attribute) . module_expr IN seq_expr]
  { "implementation: LET OPEN BANG LBRACKETAT AND RBRACKET WHILE" }

(* interface: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: FUNCTOR list(attribute) functor_args MINUSGREATER module_type .
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "interface: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER QUOTED_STRING_EXPR WHILE" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT EQUAL QUOTED_STRING_EXPR COMMA *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /with_constraint: TYPE type_parameters label_longident with_type_binder alias_type . reversed_llist(preceded(CONSTRAINT,constrain))]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT EQUAL QUOTED_STRING_EXPR COMMA" }

(* implementation: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER QUOTED_STRING_EXPR WHILE *)
| [_ /module_expr: FUNCTOR list(attribute) functor_args MINUSGREATER module_expr .
     /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN]
  { "implementation: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER QUOTED_STRING_EXPR WHILE" }

(* implementation: UIDENT DOT LPAREN MODULE PERCENT AND WHILE *)
| [_ /simple_expr: mod_longident DOT LPAREN MODULE ext . list(attribute) module_expr COLON module_type RPAREN]
  { "implementation: UIDENT DOT LPAREN MODULE PERCENT AND WHILE" }

(* implementation: FUN LPAREN TYPE WITH *)
| /expr: FUN ext list(attribute) LPAREN TYPE . nonempty_list(mkrhs(LIDENT)) RPAREN fun_def
  { "implementation: FUN LPAREN TYPE WITH" }

(* implementation: FOR FALSE EQUAL WITH *)
| /expr: FOR ext list(attribute) pattern EQUAL . seq_expr direction_flag seq_expr DO seq_expr DONE
  { "implementation: FOR FALSE EQUAL WITH" }

(* implementation: LET LIDENT COLON TYPE LIDENT DOT WITH *)
| /let_binding_body_no_punning: val_ident COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT . core_type EQUAL seq_expr
  { "implementation: LET LIDENT COLON TYPE LIDENT DOT WITH" }

(* implementation: LET LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /let_binding_body_no_punning: val_ident COLON reversed_nonempty_llist(typevar) DOT core_type . EQUAL seq_expr]
  { "implementation: LET LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR WITH" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP LPAREN WITH *)
| /simple_expr: simple_expr DOT mod_longident DOTOP LPAREN . separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP LPAREN WITH" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACKET WITH *)
| /simple_expr: simple_expr DOT mod_longident DOTOP LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACKET WITH" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACE WITH *)
| /simple_expr: simple_expr DOT mod_longident DOTOP LBRACE . separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP LBRACE WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LPAREN WITH *)
| /expr: simple_expr DOT mod_longident DOTOP LPAREN . separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS expr
  /simple_expr: simple_expr DOT mod_longident DOTOP LPAREN . separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  { "implementation: FALSE DOT UIDENT DOTOP LPAREN WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LBRACKET WITH *)
| /expr: simple_expr DOT mod_longident DOTOP LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS expr
  /simple_expr: simple_expr DOT mod_longident DOTOP LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: FALSE DOT UIDENT DOTOP LBRACKET WITH" }

(* implementation: FALSE DOT UIDENT DOTOP LBRACE WITH *)
| /expr: simple_expr DOT mod_longident DOTOP LBRACE . separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS expr
  /simple_expr: simple_expr DOT mod_longident DOTOP LBRACE . separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  { "implementation: FALSE DOT UIDENT DOTOP LBRACE WITH" }

(* implementation: IF UIDENT THEN WITH *)
| /expr: IF ext list(attribute) seq_expr THEN . expr ELSE expr
  /expr: IF ext list(attribute) seq_expr THEN . expr
  { "implementation: IF UIDENT THEN WITH" }

(* implementation: LET OPEN QUOTED_STRING_EXPR WITH *)
| [_ /expr: LET OPEN ext list(attribute) module_expr . IN seq_expr
     /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN]
  { "implementation: LET OPEN QUOTED_STRING_EXPR WITH" }

(* implementation: LET MODULE UIDENT WITH *)
| [_ /expr: LET MODULE ext list(attribute) module_name . module_binding_body IN seq_expr]
  { "implementation: LET MODULE UIDENT WITH" }

(* implementation: LET EXCEPTION FALSE WITH *)
| [_ /expr: LET EXCEPTION ext list(attribute) constr_ident . generalized_constructor_arguments list(attribute) IN seq_expr]
  { "implementation: LET EXCEPTION FALSE WITH" }

(* implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR LBRACKETAT AND RBRACKET WHILE *)
| [_ /label_declaration: mutable_flag LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) .
     /label_declaration_semi: mutable_flag LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) . SEMI list(attribute)]
  { "implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR LBRACKETAT AND RBRACKET WHILE" }

(* implementation: LET FALSE EQUAL UIDENT TO *)
| [_ /let_bindings(ext): LET ext list(attribute) rec_flag let_binding_body . list(post_item_attribute)]
  { "implementation: LET FALSE EQUAL UIDENT TO" }

(* implementation: MATCH UIDENT WITH WITH *)
| /expr: MATCH ext list(attribute) seq_expr WITH . reversed_preceded_or_separated_nonempty_llist(BAR,match_case)
  { "implementation: MATCH UIDENT WITH WITH" }

(* implementation: INCLUDE LPAREN VAL UIDENT COLONGREATER WITH *)
| /paren_module_expr: LPAREN VAL list(attribute) expr COLONGREATER . module_type RPAREN
  { "implementation: INCLUDE LPAREN VAL UIDENT COLONGREATER WITH" }

(* implementation: INCLUDE LPAREN VAL UIDENT COLON WITH *)
| /paren_module_expr: LPAREN VAL list(attribute) expr COLON . module_type RPAREN
  /paren_module_expr: LPAREN VAL list(attribute) expr COLON . module_type COLONGREATER module_type RPAREN
  { "implementation: INCLUDE LPAREN VAL UIDENT COLON WITH" }

(* implementation: OPEN BANG QUOTED_STRING_EXPR WITH *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /open_declaration: OPEN BANG ext list(attribute) module_expr . list(post_item_attribute)]
  { "implementation: OPEN BANG QUOTED_STRING_EXPR WITH" }

(* implementation: MODULE TYPE LIDENT WITH *)
| [_ /module_type_declaration: MODULE TYPE ext list(attribute) ident . option(preceded(EQUAL,module_type)) list(post_item_attribute)]
  { "implementation: MODULE TYPE LIDENT WITH" }

(* implementation: MODULE REC UIDENT WITH *)
| [_ /structure_item: MODULE ext list(attribute) REC module_name . module_binding_body list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE REC UIDENT WITH" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND UIDENT EQUAL QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(and_module_binding): AND list(attribute) module_name module_binding_body list(post_item_attribute) . list(and_module_binding)]
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND UIDENT EQUAL QUOTED_STRING_EXPR LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: MODULE UIDENT EQUAL QUOTED_STRING_EXPR IN *)
| [_ /structure_item: MODULE ext list(attribute) module_name module_binding_body . list(post_item_attribute)]
  { "implementation: MODULE UIDENT EQUAL QUOTED_STRING_EXPR IN" }

(* implementation: EXTERNAL LIDENT COLON WITH *)
| /primitive_declaration: EXTERNAL ext list(attribute) val_ident COLON . core_type EQUAL nonempty_list(raw_string) list(post_item_attribute)
  { "implementation: EXTERNAL LIDENT COLON WITH" }

(* implementation: EXCEPTION FALSE EQUAL WITH *)
| /str_exception_declaration: EXCEPTION ext list(attribute) constr_ident EQUAL . constr_longident list(attribute) list(post_item_attribute)
  { "implementation: EXCEPTION FALSE EQUAL WITH" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR CONSTRAINT *)
| [_ /sig_exception_declaration: EXCEPTION ext list(attribute) constr_ident generalized_constructor_arguments . list(attribute) list(post_item_attribute)]
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR CONSTRAINT" }

(* interface: OPEN BANG UIDENT WITH *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN
     /open_description: OPEN BANG ext list(attribute) mod_ext_longident . list(post_item_attribute)]
  { "interface: OPEN BANG UIDENT WITH" }

(* interface: MODULE TYPE LIDENT WITH *)
| [_ /module_type_declaration: MODULE TYPE ext list(attribute) ident . option(preceded(EQUAL,module_type)) list(post_item_attribute)
     /module_type_subst: MODULE TYPE ext list(attribute) ident . COLONEQUAL module_type list(post_item_attribute)]
  { "interface: MODULE TYPE LIDENT WITH" }

(* interface: MODULE UIDENT COLONEQUAL WITH *)
| /module_subst: MODULE ext list(attribute) UIDENT COLONEQUAL . mod_ext_longident list(post_item_attribute)
  { "interface: MODULE UIDENT COLONEQUAL WITH" }

(* interface: MODULE REC UIDENT WITH *)
| [_ /signature_item: MODULE ext list(attribute) REC module_name . COLON module_type list(post_item_attribute) list(and_module_declaration)]
  { "interface: MODULE REC UIDENT WITH" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /list(and_module_declaration): AND list(attribute) module_name COLON module_type . list(post_item_attribute) list(and_module_declaration)
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* interface: MODULE UIDENT EQUAL WITH *)
| /signature_item: MODULE ext list(attribute) module_name EQUAL . mod_longident list(post_item_attribute)
  { "interface: MODULE UIDENT EQUAL WITH" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT COLONEQUAL WITH *)
| /list(generic_and_type_declaration(type_subst_kind)): AND list(attribute) type_parameters LIDENT COLONEQUAL . nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_subst_kind))
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT COLONEQUAL WITH" }

(* implementation: LPAREN MODULE QUOTED_STRING_EXPR WITH *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /simple_expr: LPAREN MODULE ext list(attribute) module_expr . RPAREN
     /simple_expr: LPAREN MODULE ext list(attribute) module_expr . COLON module_type RPAREN]
  { "implementation: LPAREN MODULE QUOTED_STRING_EXPR WITH" }

(* implementation: TRY UIDENT WITH WITH *)
| /expr: TRY ext list(attribute) seq_expr WITH . reversed_preceded_or_separated_nonempty_llist(BAR,match_case)
  { "implementation: TRY UIDENT WITH WITH" }

(* implementation: TYPE LIDENT WITH *)
| /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) type_parameters LIDENT . type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "implementation: TYPE LIDENT WITH" }

(* implementation: TYPE UIDENT DOT LIDENT WHILE *)
| [_ /structure_item: TYPE ext list(attribute) type_parameters type_longident . PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE UIDENT DOT LIDENT WHILE" }

(* parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR SEMI WITH *)
| /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) SEMI . list(attribute) meth_list
  /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) SEMI . list(attribute)
  { "parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR SEMI WITH" }

(* interface: TYPE LIDENT WITH *)
| /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) type_parameters LIDENT . COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) type_parameters LIDENT . type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "interface: TYPE LIDENT WITH" }

(* interface: TYPE UIDENT DOT LIDENT WHILE *)
| [_ /signature_item: TYPE ext list(attribute) type_parameters type_longident . PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE UIDENT DOT LIDENT WHILE" }

(* parse_core_type: LPAREN MODULE QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: LPAREN MODULE ext list(attribute) module_type . RPAREN
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "parse_core_type: LPAREN MODULE QUOTED_STRING_EXPR WHILE" }

(* implementation: WHILE UIDENT DO WITH *)
| /expr: WHILE ext list(attribute) seq_expr DO . seq_expr DONE
  { "implementation: WHILE UIDENT DO WITH" }

(* interface: TYPE NONREC WITH *)
| /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) NONREC . type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC . type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /signature_item: TYPE ext list(attribute) NONREC . type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
  { "interface: TYPE NONREC WITH" }

(* implementation: LPAREN DOTOP LPAREN RPAREN WITH *)
| /operator: DOTOP LPAREN index_mod RPAREN .
  /operator: DOTOP LPAREN index_mod RPAREN . LESSMINUS
  { "implementation: LPAREN DOTOP LPAREN RPAREN WITH" }

(* implementation: LPAREN DOTOP LBRACKET RBRACKET WITH *)
| /operator: DOTOP LBRACKET index_mod RBRACKET .
  /operator: DOTOP LBRACKET index_mod RBRACKET . LESSMINUS
  { "implementation: LPAREN DOTOP LBRACKET RBRACKET WITH" }

(* implementation: LPAREN DOTOP LBRACE RBRACE WITH *)
| /operator: DOTOP LBRACE index_mod RBRACE .
  /operator: DOTOP LBRACE index_mod RBRACE . LESSMINUS
  { "implementation: LPAREN DOTOP LBRACE RBRACE WITH" }

(* implementation: VAL LIDENT WITH *)
| [_ /value_description: VAL ext list(attribute) val_ident . COLON core_type list(post_item_attribute)]
  { "implementation: VAL LIDENT WITH" }

(* parse_core_type: LPAREN MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /atomic_type: LPAREN MODULE ext list(attribute) . module_type RPAREN]
  { "parse_core_type: LPAREN MODULE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: TYPE NONREC WITH *)
| /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) NONREC . type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /structure_item: TYPE ext list(attribute) NONREC . type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
  { "implementation: TYPE NONREC WITH" }

(* implementation: BEGIN UIDENT VAL *)
| [_ /simple_expr: BEGIN ext list(attribute) seq_expr . END]
  { "implementation: BEGIN UIDENT VAL" }

(* interface: CLASS VIRTUAL WITH *)
| [_ /signature_item: CLASS ext list(attribute) virtual_flag . formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS VIRTUAL WITH" }

(* implementation: CLASS LIDENT COLON LIDENT COLON QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /class_type: LIDENT COLON tuple_type MINUSGREATER . class_type
  { "implementation: CLASS LIDENT COLON LIDENT COLON QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LBRACKET UNDERSCORE RBRACKET WITH *)
| [_ /list(and_class_description): AND list(attribute) virtual_flag formal_class_parameters . LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LBRACKET UNDERSCORE RBRACKET WITH" }

(* implementation: CLASS VIRTUAL WITH *)
| [_ /structure_item: CLASS ext list(attribute) virtual_flag . formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS VIRTUAL WITH" }

(* implementation: OBJECT VAL BANG LIDENT WITH *)
| /value: BANG list(attribute) mutable_flag LIDENT . EQUAL seq_expr
  /value: BANG list(attribute) mutable_flag LIDENT . type_constraint EQUAL seq_expr
  { "implementation: OBJECT VAL BANG LIDENT WITH" }

(* implementation: OBJECT VAL VIRTUAL LIDENT COLON WITH *)
| /value: list(attribute) virtual_with_mutable_flag LIDENT COLON . core_type
  { "implementation: OBJECT VAL VIRTUAL LIDENT COLON WITH" }

(* implementation: OBJECT VAL LIDENT EQUAL WITH *)
| /value: list(attribute) mutable_flag LIDENT EQUAL . seq_expr
  { "implementation: OBJECT VAL LIDENT EQUAL WITH" }

(* implementation: OBJECT VAL LIDENT COLON QUOTED_STRING_EXPR RBRACE *)
| [_ /value: list(attribute) mutable_flag LIDENT type_constraint . EQUAL seq_expr]
  { "implementation: OBJECT VAL LIDENT COLON QUOTED_STRING_EXPR RBRACE" }

(* implementation: OBJECT METHOD BANG LIDENT WITH *)
| /method_: BANG list(attribute) private_flag LIDENT . strict_binding
  /method_: BANG list(attribute) private_flag LIDENT . COLON possibly_poly(core_type) EQUAL seq_expr
  /method_: BANG list(attribute) private_flag LIDENT . COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD BANG LIDENT WITH" }

(* implementation: OBJECT METHOD VIRTUAL LIDENT COLON WITH *)
| /method_: list(attribute) virtual_with_private_flag LIDENT COLON . possibly_poly(core_type)
  { "implementation: OBJECT METHOD VIRTUAL LIDENT COLON WITH" }

(* implementation: OBJECT METHOD LIDENT COLON WITH *)
| /method_: list(attribute) private_flag LIDENT COLON . possibly_poly(core_type) EQUAL seq_expr
  /method_: list(attribute) private_flag LIDENT COLON . TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD LIDENT COLON WITH" }

(* implementation: OBJECT INHERIT LET PERCENT AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /let_bindings(no_ext): LET PERCENT attr_id list(attribute) . rec_flag let_binding_body list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET PERCENT AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT LET OPEN BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_expr: LET OPEN BANG list(attribute) . mod_longident IN class_expr]
  { "implementation: OBJECT INHERIT LET OPEN BANG LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT LET OPEN UIDENT WITH *)
| [_ /class_expr: LET OPEN list(attribute) mod_longident . IN class_expr
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT]
  { "implementation: OBJECT INHERIT LET OPEN UIDENT WITH" }

(* implementation: OBJECT INHERIT LET LIDENT VAL *)
| [_ /let_bindings(no_ext): LET list(attribute) rec_flag let_binding_body . list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET LIDENT VAL" }

(* implementation: OBJECT INHERIT LPAREN LIDENT COLON QUOTED_STRING_EXPR VAL *)
| [_ /class_simple_expr: LPAREN class_expr COLON class_type . RPAREN]
  { "implementation: OBJECT INHERIT LPAREN LIDENT COLON QUOTED_STRING_EXPR VAL" }

(* implementation: OBJECT INHERIT BANG QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: class_expr . attribute
     /class_field: INHERIT BANG list(attribute) class_expr . option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)]
  { "implementation: OBJECT INHERIT BANG QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT INHERIT LIDENT AS LIDENT WITH *)
| [_ /class_field: INHERIT list(attribute) class_expr option(preceded(AS,mkrhs(LIDENT))) . list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LIDENT AS LIDENT WITH" }

(* implementation: CLASS LIDENT EQUAL LIDENT AND LBRACKET UNDERSCORE RBRACKET WITH *)
| [_ /list(and_class_declaration): AND list(attribute) virtual_flag formal_class_parameters . LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS LIDENT EQUAL LIDENT AND LBRACKET UNDERSCORE RBRACKET WITH" }

(* implementation: CLASS TYPE LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_type_declarations: CLASS TYPE ext list(attribute) . virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON OBJECT VAL LIDENT WITH *)
| /class_sig_field: VAL list(attribute) mutable_virtual_flags LIDENT . COLON core_type list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT VAL LIDENT WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD LIDENT WITH *)
| /class_sig_field: METHOD list(attribute) private_virtual_flags LIDENT . COLON possibly_poly(core_type) list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT METHOD LIDENT WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_signature: LET OPEN BANG list(attribute) . mod_longident IN class_signature]
  { "implementation: CLASS LIDENT COLON LET OPEN BANG LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON LET OPEN UIDENT WITH *)
| [_ /class_signature: LET OPEN list(attribute) mod_longident . IN class_signature
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT]
  { "implementation: CLASS LIDENT COLON LET OPEN UIDENT WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LBRACKET UNDERSCORE RBRACKET WITH *)
| [_ /list(and_class_type_declaration): AND list(attribute) virtual_flag formal_class_parameters . LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LBRACKET UNDERSCORE RBRACKET WITH" }

(* parse_pattern: LPAREN MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /simple_pattern_not_ident: LPAREN MODULE ext list(attribute) . module_name RPAREN
     /simple_pattern_not_ident: LPAREN MODULE ext list(attribute) . module_name COLON module_type RPAREN]
  { "parse_pattern: LPAREN MODULE LBRACKETAT AND RBRACKET WHILE" }

(* interface: INCLUDE MODULE TYPE OF LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_type: MODULE TYPE OF list(attribute) . module_expr]
  { "interface: INCLUDE MODULE TYPE OF LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OPEN BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /open_declaration: OPEN BANG ext list(attribute) . module_expr list(post_item_attribute)]
  { "implementation: OPEN BANG LBRACKETAT AND RBRACKET WHILE" }

(* parse_core_type: LBRACKET QUOTED_STRING_EXPR BAR QUOTED_STRING_EXPR GREATER *)
| [_ /atomic_type: LBRACKET row_field BAR reversed_separated_nonempty_llist(BAR,row_field) . RBRACKET
     /reversed_separated_nonempty_llist(BAR,row_field): reversed_separated_nonempty_llist(BAR,row_field) . BAR row_field]
  { "parse_core_type: LBRACKET QUOTED_STRING_EXPR BAR QUOTED_STRING_EXPR GREATER" }

(* parse_core_type: LBRACKETLESS QUOTED_STRING_EXPR GREATER WITH *)
| /atomic_type: LBRACKETLESS option(BAR) reversed_separated_nonempty_llist(BAR,row_field) GREATER . reversed_nonempty_llist(name_tag) RBRACKET
  { "parse_core_type: LBRACKETLESS QUOTED_STRING_EXPR GREATER WITH" }

(* parse_pattern: FALSE LPAREN TYPE LIDENT DOT *)
| [_ /pattern_gen: constr_longident LPAREN TYPE nonempty_list(mkrhs(LIDENT)) . RPAREN simple_pattern]
  { "parse_pattern: FALSE LPAREN TYPE LIDENT DOT" }

(* parse_pattern: LPAREN FALSE COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /simple_pattern_not_ident: LPAREN pattern COLON core_type . RPAREN]
  { "parse_pattern: LPAREN FALSE COLON QUOTED_STRING_EXPR WITH" }

(* implementation: UIDENT DOT LPAREN COLONCOLON WITH *)
| /constr_longident: mod_longident DOT LPAREN COLONCOLON . RPAREN
  { "implementation: UIDENT DOT LPAREN COLONCOLON WITH" }

(* parse_pattern: UIDENT DOT LPAREN QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /simple_pattern_not_ident: mod_longident DOT LPAREN pattern . RPAREN]
  { "parse_pattern: UIDENT DOT LPAREN QUOTED_STRING_EXPR WHILE" }

(* parse_pattern: LBRACE LIDENT SEMI WITH *)
| /listx(SEMI,record_pat_field,UNDERSCORE): label_longident option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI .
  /listx(SEMI,record_pat_field,UNDERSCORE): label_longident option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI . UNDERSCORE option(SEMI)
  /listx(SEMI,record_pat_field,UNDERSCORE): label_longident option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI . listx(SEMI,record_pat_field,UNDERSCORE)
  { "parse_pattern: LBRACE LIDENT SEMI WITH" }

(* implementation: LET OPEN BANG PERCENT AND WHILE *)
| [_ /expr: LET OPEN BANG ext . list(attribute) module_expr IN seq_expr]
  { "implementation: LET OPEN BANG PERCENT AND WHILE" }

(* interface: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER WITH *)
| /module_type: FUNCTOR list(attribute) functor_args MINUSGREATER . module_type
  { "interface: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT COLONEQUAL WITH *)
| /with_constraint: TYPE type_parameters label_longident COLONEQUAL . alias_type
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT COLONEQUAL WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT EQUAL PRIVATE WITH *)
| [_ /with_constraint: TYPE type_parameters label_longident with_type_binder . alias_type reversed_llist(preceded(CONSTRAINT,constrain))]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT EQUAL PRIVATE WITH" }

(* implementation: TYPE LIDENT CONSTRAINT QUOTED_STRING_EXPR EQUAL WITH *)
| /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) CONSTRAINT core_type EQUAL . core_type
  { "implementation: TYPE LIDENT CONSTRAINT QUOTED_STRING_EXPR EQUAL WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT EQUAL WITH *)
| /with_constraint: MODULE TYPE mty_longident EQUAL . module_type
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT EQUAL WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT COLONEQUAL WITH *)
| /with_constraint: MODULE TYPE mty_longident COLONEQUAL . module_type
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT COLONEQUAL WITH" }

(* implementation: MODULE UIDENT LPAREN UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /functor_arg: LPAREN module_name COLON module_type . RPAREN
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "implementation: MODULE UIDENT LPAREN UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER WITH *)
| /module_expr: FUNCTOR list(attribute) functor_args MINUSGREATER . module_expr
  { "implementation: INCLUDE FUNCTOR LPAREN RPAREN MINUSGREATER WITH" }

(* implementation: INCLUDE LPAREN QUOTED_STRING_EXPR COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /paren_module_expr: LPAREN module_expr COLON module_type . RPAREN]
  { "implementation: INCLUDE LPAREN QUOTED_STRING_EXPR COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: UIDENT DOT LPAREN MODULE WITH *)
| /simple_expr: mod_longident DOT LPAREN MODULE . ext list(attribute) module_expr COLON module_type RPAREN
  { "implementation: UIDENT DOT LPAREN MODULE WITH" }

(* implementation: LETOP LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /letop_binding_body: simple_pattern COLON core_type EQUAL . seq_expr
  { "implementation: LETOP LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: FUN OPTLABEL LPAREN FALSE EQUAL UIDENT VAL *)
| [_ /labeled_simple_pattern: OPTLABEL LPAREN let_pattern option(preceded(EQUAL,seq_expr)) . RPAREN]
  { "implementation: FUN OPTLABEL LPAREN FALSE EQUAL UIDENT VAL" }

(* implementation: FUN LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  /expr: FUN ext list(attribute) LPAREN . TYPE nonempty_list(mkrhs(LIDENT)) RPAREN fun_def
  /simple_pattern_not_ident: LPAREN . pattern RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name COLON module_type RPAREN
  /simple_pattern_not_ident: LPAREN . pattern COLON core_type RPAREN
  /val_extra_ident: LPAREN . operator RPAREN
  { "implementation: FUN LPAREN WITH" }

(* implementation: FOR QUOTED_STRING_EXPR WHILE *)
| [_ /expr: FOR ext list(attribute) pattern . EQUAL seq_expr direction_flag seq_expr DO seq_expr DONE
     /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern]
  { "implementation: FOR QUOTED_STRING_EXPR WHILE" }

(* implementation: UIDENT CHAR DOT LPAREN UIDENT VAL *)
| [_ /simple_expr: simple_expr DOT LPAREN seq_expr . RPAREN]
  { "implementation: UIDENT CHAR DOT LPAREN UIDENT VAL" }

(* implementation: UIDENT SEMI PERCENT AND VIRTUAL *)
| [_ /seq_expr: expr SEMI PERCENT attr_id . seq_expr]
  { "implementation: UIDENT SEMI PERCENT AND VIRTUAL" }

(* implementation: LETOP LIDENT LPAREN TYPE LIDENT RPAREN WITH *)
| /strict_binding: LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN . fun_binding
  { "implementation: LETOP LIDENT LPAREN TYPE LIDENT RPAREN WITH" }

(* implementation: LET LIDENT COLON TYPE LIDENT RPAREN *)
| [_ /let_binding_body_no_punning: val_ident COLON TYPE nonempty_list(mkrhs(LIDENT)) . DOT core_type EQUAL seq_expr]
  { "implementation: LET LIDENT COLON TYPE LIDENT RPAREN" }

(* implementation: LET LIDENT COLON QUOTE LIDENT DOT WITH *)
| /let_binding_body_no_punning: val_ident COLON reversed_nonempty_llist(typevar) DOT . core_type EQUAL seq_expr
  { "implementation: LET LIDENT COLON QUOTE LIDENT DOT WITH" }

(* implementation: LET FALSE COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /let_binding_body_no_punning: simple_pattern_not_ident COLON core_type EQUAL . seq_expr
  { "implementation: LET FALSE COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: UIDENT CHAR DOT LBRACKET UIDENT VAL *)
| [_ /simple_expr: simple_expr DOT LBRACKET seq_expr . RBRACKET]
  { "implementation: UIDENT CHAR DOT LBRACKET UIDENT VAL" }

(* implementation: UIDENT CHAR DOT LBRACE UIDENT VAL *)
| [_ /simple_expr: simple_expr DOT LBRACE seq_expr . RBRACE]
  { "implementation: UIDENT CHAR DOT LBRACE UIDENT VAL" }

(* implementation: UIDENT CHAR DOT UIDENT DOTOP WITH *)
| /simple_expr: simple_expr DOT mod_longident DOTOP . LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  /simple_expr: simple_expr DOT mod_longident DOTOP . LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  /simple_expr: simple_expr DOT mod_longident DOTOP . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: UIDENT CHAR DOT UIDENT DOTOP WITH" }

(* implementation: UIDENT DOTOP LPAREN UIDENT RBRACKET *)
| [_ /expr: simple_expr DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) . RPAREN LESSMINUS expr
     /simple_expr: simple_expr DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) . RPAREN]
  { "implementation: UIDENT DOTOP LPAREN UIDENT RBRACKET" }

(* implementation: UIDENT DOTOP LBRACKET UIDENT RPAREN *)
| [_ /expr: simple_expr DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET LESSMINUS expr
     /simple_expr: simple_expr DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET]
  { "implementation: UIDENT DOTOP LBRACKET UIDENT RPAREN" }

(* implementation: UIDENT DOTOP LBRACE UIDENT RPAREN *)
| [_ /expr: simple_expr DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) . RBRACE LESSMINUS expr
     /simple_expr: simple_expr DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) . RBRACE]
  { "implementation: UIDENT DOTOP LBRACE UIDENT RPAREN" }

(* implementation: FALSE DOT LPAREN UIDENT VAL *)
| [_ /expr: simple_expr DOT LPAREN seq_expr . RPAREN LESSMINUS expr
     /simple_expr: simple_expr DOT LPAREN seq_expr . RPAREN]
  { "implementation: FALSE DOT LPAREN UIDENT VAL" }

(* implementation: FALSE DOT LBRACKET UIDENT VAL *)
| [_ /expr: simple_expr DOT LBRACKET seq_expr . RBRACKET LESSMINUS expr
     /simple_expr: simple_expr DOT LBRACKET seq_expr . RBRACKET]
  { "implementation: FALSE DOT LBRACKET UIDENT VAL" }

(* implementation: FALSE DOT LBRACE UIDENT VAL *)
| [_ /expr: simple_expr DOT LBRACE seq_expr . RBRACE LESSMINUS expr
     /simple_expr: simple_expr DOT LBRACE seq_expr . RBRACE]
  { "implementation: FALSE DOT LBRACE UIDENT VAL" }

(* implementation: FALSE DOT UIDENT DOTOP WITH *)
| /expr: simple_expr DOT mod_longident DOTOP . LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS expr
  /expr: simple_expr DOT mod_longident DOTOP . LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS expr
  /expr: simple_expr DOT mod_longident DOTOP . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS expr
  /simple_expr: simple_expr DOT mod_longident DOTOP . LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  /simple_expr: simple_expr DOT mod_longident DOTOP . LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  /simple_expr: simple_expr DOT mod_longident DOTOP . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: FALSE DOT UIDENT DOTOP WITH" }

(* implementation: FALSE DOT LIDENT LESSMINUS WITH *)
| /expr: simple_expr DOT label_longident LESSMINUS . expr
  { "implementation: FALSE DOT LIDENT LESSMINUS WITH" }

(* implementation: UIDENT CHAR DOTOP LPAREN UIDENT RBRACKET *)
| [_ /simple_expr: simple_expr DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) . RPAREN]
  { "implementation: UIDENT CHAR DOTOP LPAREN UIDENT RBRACKET" }

(* implementation: UIDENT CHAR DOTOP LBRACKET UIDENT RPAREN *)
| [_ /simple_expr: simple_expr DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET]
  { "implementation: UIDENT CHAR DOTOP LBRACKET UIDENT RPAREN" }

(* implementation: UIDENT CHAR DOTOP LBRACE UIDENT RPAREN *)
| [_ /simple_expr: simple_expr DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) . RBRACE]
  { "implementation: UIDENT CHAR DOTOP LBRACE UIDENT RPAREN" }

(* implementation: FUN FALSE LPAREN TYPE LIDENT RPAREN WITH *)
| /fun_def: LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN . fun_def
  { "implementation: FUN FALSE LPAREN TYPE LIDENT RPAREN WITH" }

(* implementation: FUN FALSE WHILE *)
| [_ /expr: FUN ext list(attribute) labeled_simple_pattern . fun_def]
  { "implementation: FUN FALSE WHILE" }

(* implementation: FUNCTION FALSE WHEN UIDENT MINUSGREATER WITH *)
| /match_case: pattern WHEN seq_expr MINUSGREATER . seq_expr
  { "implementation: FUNCTION FALSE WHEN UIDENT MINUSGREATER WITH" }

(* implementation: IF UIDENT VAL *)
| [_ /expr: IF ext list(attribute) seq_expr . THEN expr ELSE expr
     /expr: IF ext list(attribute) seq_expr . THEN expr]
  { "implementation: IF UIDENT VAL" }

(* implementation: UIDENT DOT LPAREN UIDENT VAL *)
| [_ /simple_expr: mod_longident DOT LPAREN seq_expr . RPAREN]
  { "implementation: UIDENT DOT LPAREN UIDENT VAL" }

(* implementation: UIDENT DOT LBRACKETBAR UIDENT RPAREN *)
| [_ /simple_expr: mod_longident DOT LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,expr) . BARRBRACKET]
  { "implementation: UIDENT DOT LBRACKETBAR UIDENT RPAREN" }

(* implementation: UIDENT DOT LBRACKET UIDENT RPAREN *)
| [_ /simple_expr: mod_longident DOT LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET]
  { "implementation: UIDENT DOT LBRACKET UIDENT RPAREN" }

(* implementation: LBRACE LIDENT SEMI WITH *)
| /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) option(preceded(EQUAL,expr)) SEMI .
  /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) option(preceded(EQUAL,expr)) SEMI . separated_or_terminated_nonempty_list(SEMI,record_expr_field)
  { "implementation: LBRACE LIDENT SEMI WITH" }

(* implementation: LET OPEN LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: LET OPEN ext list(attribute) . module_expr IN seq_expr]
  { "implementation: LET OPEN LBRACKETAT AND RBRACKET WHILE" }

(* implementation: LET MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: LET MODULE ext list(attribute) . module_name module_binding_body IN seq_expr]
  { "implementation: LET MODULE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: MODULE UIDENT COLON QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR WITH *)
| [_ /module_binding_body: COLON module_type EQUAL module_expr .
     /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN]
  { "implementation: MODULE UIDENT COLON QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR WITH" }

(* implementation: LET EXCEPTION LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: LET EXCEPTION ext list(attribute) . constr_ident generalized_constructor_arguments list(attribute) IN seq_expr]
  { "implementation: LET EXCEPTION LBRACKETAT AND RBRACKET WHILE" }

(* implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR GREATER *)
| [_ /label_declaration: mutable_flag LIDENT COLON possibly_poly(core_type_no_attr) . list(attribute)
     /label_declaration_semi: mutable_flag LIDENT COLON possibly_poly(core_type_no_attr) . list(attribute) SEMI list(attribute)]
  { "implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR GREATER" }

(* implementation: LET REC WITH *)
| [_ /let_bindings(ext): LET ext list(attribute) rec_flag . let_binding_body list(post_item_attribute)]
  { "implementation: LET REC WITH" }

(* implementation: FUN QUESTION LPAREN LIDENT EQUAL UIDENT VAL *)
| [_ /labeled_simple_pattern: QUESTION LPAREN label_let_pattern option(preceded(EQUAL,seq_expr)) . RPAREN]
  { "implementation: FUN QUESTION LPAREN LIDENT EQUAL UIDENT VAL" }

(* implementation: MATCH UIDENT VAL *)
| [_ /expr: MATCH ext list(attribute) seq_expr . WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: MATCH UIDENT VAL" }

(* implementation: INCLUDE LPAREN VAL UIDENT VAL *)
| [_ /expr: expr . INFIXOP0 expr
     /expr: expr . INFIXOP1 expr
     /expr: expr . INFIXOP2 expr
     /expr: expr . INFIXOP3 expr
     /expr: expr . INFIXOP4 expr
     /expr: expr . PLUS expr
     /expr: expr . PLUSDOT expr
     /expr: expr . PLUSEQ expr
     /expr: expr . MINUS expr
     /expr: expr . MINUSDOT expr
     /expr: expr . STAR expr
     /expr: expr . PERCENT expr
     /expr: expr . EQUAL expr
     /expr: expr . LESS expr
     /expr: expr . GREATER expr
     /expr: expr . OR expr
     /expr: expr . BARBAR expr
     /expr: expr . AMPERSAND expr
     /expr: expr . AMPERAMPER expr
     /expr: expr . COLONEQUAL expr
     /expr: expr . COLONCOLON expr
     /expr: expr . attribute
     /paren_module_expr: LPAREN VAL list(attribute) expr . RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) expr . COLON module_type RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) expr . COLON module_type COLONGREATER module_type RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) expr . COLONGREATER module_type RPAREN
     /reversed_separated_nontrivial_llist(COMMA,expr): expr . COMMA expr]
  { "implementation: INCLUDE LPAREN VAL UIDENT VAL" }

(* implementation: OPEN QUOTED_STRING_EXPR WITH *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /open_declaration: OPEN ext list(attribute) module_expr . list(post_item_attribute)]
  { "implementation: OPEN QUOTED_STRING_EXPR WITH" }

(* implementation: MODULE TYPE LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_type_declaration: MODULE TYPE ext list(attribute) . ident option(preceded(EQUAL,module_type)) list(post_item_attribute)]
  { "implementation: MODULE TYPE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: MODULE REC WITH *)
| /structure_item: MODULE ext list(attribute) REC . module_name module_binding_body list(post_item_attribute) list(and_module_binding)
  { "implementation: MODULE REC WITH" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND UIDENT EQUAL QUOTED_STRING_EXPR IN *)
| [_ /list(and_module_binding): AND list(attribute) module_name module_binding_body . list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND UIDENT EQUAL QUOTED_STRING_EXPR IN" }

(* implementation: MODULE UIDENT WITH *)
| [_ /structure_item: MODULE ext list(attribute) module_name . module_binding_body list(post_item_attribute)]
  { "implementation: MODULE UIDENT WITH" }

(* implementation: INCLUDE QUOTED_STRING_EXPR WITH *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /structure_item: INCLUDE ext list(attribute) module_expr . list(post_item_attribute)]
  { "implementation: INCLUDE QUOTED_STRING_EXPR WITH" }

(* implementation: EXTERNAL LIDENT WITH *)
| [_ /primitive_declaration: EXTERNAL ext list(attribute) val_ident . COLON core_type EQUAL nonempty_list(raw_string) list(post_item_attribute)]
  { "implementation: EXTERNAL LIDENT WITH" }

(* implementation: EXCEPTION FALSE WITH *)
| [_ /sig_exception_declaration: EXCEPTION ext list(attribute) constr_ident . generalized_constructor_arguments list(attribute) list(post_item_attribute)
     /str_exception_declaration: EXCEPTION ext list(attribute) constr_ident . EQUAL constr_longident list(attribute) list(post_item_attribute)]
  { "implementation: EXCEPTION FALSE WITH" }

(* interface: OPEN BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /open_description: OPEN BANG ext list(attribute) . mod_ext_longident list(post_item_attribute)]
  { "interface: OPEN BANG LBRACKETAT AND RBRACKET WHILE" }

(* interface: OPEN UIDENT WITH *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN
     /open_description: OPEN ext list(attribute) mod_ext_longident . list(post_item_attribute)]
  { "interface: OPEN UIDENT WITH" }

(* interface: MODULE TYPE LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_type_declaration: MODULE TYPE ext list(attribute) . ident option(preceded(EQUAL,module_type)) list(post_item_attribute)
     /module_type_subst: MODULE TYPE ext list(attribute) . ident COLONEQUAL module_type list(post_item_attribute)]
  { "interface: MODULE TYPE LBRACKETAT AND RBRACKET WHILE" }

(* interface: MODULE UIDENT WITH *)
| /module_name: UIDENT .
  /module_subst: MODULE ext list(attribute) UIDENT . COLONEQUAL mod_ext_longident list(post_item_attribute)
  { "interface: MODULE UIDENT WITH" }

(* interface: MODULE REC WITH *)
| /signature_item: MODULE ext list(attribute) REC . module_name COLON module_type list(post_item_attribute) list(and_module_declaration)
  { "interface: MODULE REC WITH" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT COLON WITH *)
| /list(and_module_declaration): AND list(attribute) module_name COLON . module_type list(post_item_attribute) list(and_module_declaration)
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT COLON WITH" }

(* interface: MODULE UNDERSCORE WITH *)
| [_ /signature_item: MODULE ext list(attribute) module_name . module_declaration_body list(post_item_attribute)
     /signature_item: MODULE ext list(attribute) module_name . EQUAL mod_longident list(post_item_attribute)]
  { "interface: MODULE UNDERSCORE WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /signature_item: INCLUDE ext list(attribute) module_type . list(post_item_attribute)]
  { "interface: INCLUDE QUOTED_STRING_EXPR WHILE" }

(* interface: EXCEPTION FALSE WITH *)
| [_ /sig_exception_declaration: EXCEPTION ext list(attribute) constr_ident . generalized_constructor_arguments list(attribute) list(post_item_attribute)]
  { "interface: EXCEPTION FALSE WITH" }

(* implementation: TYPE LIDENT AND LIDENT WITH *)
| /list(generic_and_type_declaration(type_kind)): AND list(attribute) type_parameters LIDENT . type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_kind))
  { "implementation: TYPE LIDENT AND LIDENT WITH" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT WITH *)
| /list(generic_and_type_declaration(type_subst_kind)): AND list(attribute) type_parameters LIDENT . COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_subst_kind))
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND LIDENT WITH" }

(* implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL PRIVATE LBRACE WITH *)
| /nonempty_type_kind: core_type EQUAL PRIVATE LBRACE . label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL PRIVATE LBRACE WITH" }

(* implementation: OBJECT LPAREN FALSE COLON QUOTED_STRING_EXPR WITH *)
| [_ /class_self_pattern: LPAREN pattern COLON core_type . RPAREN
     /core_type: core_type . attribute]
  { "implementation: OBJECT LPAREN FALSE COLON QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT LPAREN FALSE RPAREN WITH *)
| [_ /expr: OBJECT ext list(attribute) class_self_pattern . list(text_cstr(class_field)) END]
  { "implementation: OBJECT LPAREN FALSE RPAREN WITH" }

(* implementation: LPAREN MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /simple_expr: LPAREN MODULE ext list(attribute) . module_expr RPAREN
     /simple_expr: LPAREN MODULE ext list(attribute) . module_expr COLON module_type RPAREN]
  { "implementation: LPAREN MODULE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: TRY UIDENT VAL *)
| [_ /expr: TRY ext list(attribute) seq_expr . WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: TRY UIDENT VAL" }

(* implementation: TYPE LIDENT PLUSEQ BAR FALSE EQUAL FALSE WITH *)
| [_ /extension_constructor_rebind(BAR): BAR constr_ident EQUAL constr_longident . list(attribute)]
  { "implementation: TYPE LIDENT PLUSEQ BAR FALSE EQUAL FALSE WITH" }

(* implementation: TYPE UNDERSCORE WITH *)
| [_ /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) type_parameters . LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /structure_item: TYPE ext list(attribute) type_parameters . type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE UNDERSCORE WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR LBRACKETAT AND RBRACKET WHILE *)
| [_ /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) . SEMI list(attribute) meth_list
     /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) . SEMI list(attribute)
     /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) .]
  { "parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR LBRACKETAT AND RBRACKET WHILE" }

(* parse_core_type: LIDENT COLON QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /function_type: LIDENT COLON tuple_type MINUSGREATER . function_type
  { "parse_core_type: LIDENT COLON QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR RPAREN HASH WITH *)
| /atomic_type: LPAREN reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN HASH . clty_longident
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR RPAREN HASH WITH" }

(* interface: TYPE UNDERSCORE WITH *)
| [_ /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) type_parameters . LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) type_parameters . LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /signature_item: TYPE ext list(attribute) type_parameters . type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE UNDERSCORE WITH" }

(* implementation: WHILE UIDENT VAL *)
| [_ /expr: WHILE ext list(attribute) seq_expr . DO seq_expr DONE]
  { "implementation: WHILE UIDENT VAL" }

(* interface: TYPE LBRACKETAT AND RBRACKET WHILE *)
| [_ /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) . type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext list(attribute) . NONREC type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) . type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) . NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /signature_item: TYPE ext list(attribute) . type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
     /signature_item: TYPE ext list(attribute) . NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: TYPE LBRACKETAT AND RBRACKET WHILE *)
| [_ /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) . type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext list(attribute) . NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /structure_item: TYPE ext list(attribute) . type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
     /structure_item: TYPE ext list(attribute) . NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: VAL LBRACKETAT AND RBRACKET WHILE *)
| [_ /value_description: VAL ext list(attribute) . val_ident COLON core_type list(post_item_attribute)]
  { "implementation: VAL LBRACKETAT AND RBRACKET WHILE" }

(* implementation: LPAREN DOTOP LPAREN SEMI DOTDOT WITH *)
| [_ /operator: DOTOP LPAREN index_mod . RPAREN
     /operator: DOTOP LPAREN index_mod . RPAREN LESSMINUS]
  { "implementation: LPAREN DOTOP LPAREN SEMI DOTDOT WITH" }

(* implementation: LPAREN DOTOP LBRACKET SEMI DOTDOT WITH *)
| [_ /operator: DOTOP LBRACKET index_mod . RBRACKET
     /operator: DOTOP LBRACKET index_mod . RBRACKET LESSMINUS]
  { "implementation: LPAREN DOTOP LBRACKET SEMI DOTDOT WITH" }

(* implementation: LPAREN DOTOP LBRACE SEMI DOTDOT WITH *)
| [_ /operator: DOTOP LBRACE index_mod . RBRACE
     /operator: DOTOP LBRACE index_mod . RBRACE LESSMINUS]
  { "implementation: LPAREN DOTOP LBRACE SEMI DOTDOT WITH" }

(* parse_core_type: LPAREN MODULE PERCENT AND WHILE *)
| [_ /atomic_type: LPAREN MODULE ext . list(attribute) module_type RPAREN]
  { "parse_core_type: LPAREN MODULE PERCENT AND WHILE" }

(* implementation: TRY LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /expr: TRY ext list(attribute) . seq_expr WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: TRY LBRACKETAT AND RBRACKET VIRTUAL" }

(* implementation: NEW LBRACKETAT AND RBRACKET WHILE *)
| [_ /simple_expr: NEW ext list(attribute) . class_longident]
  { "implementation: NEW LBRACKETAT AND RBRACKET WHILE" }

(* implementation: BEGIN LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /simple_expr: BEGIN ext list(attribute) . seq_expr END
     /simple_expr: BEGIN ext list(attribute) . END]
  { "implementation: BEGIN LBRACKETAT AND RBRACKET VIRTUAL" }

(* interface: CLASS LBRACKETAT AND RBRACKET WHILE *)
| [_ /signature_item: CLASS ext list(attribute) . virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /class_type: LIDENT COLON tuple_type . MINUSGREATER class_type]
  { "implementation: CLASS LIDENT COLON LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OPTLABEL QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /class_type: optlabel tuple_type MINUSGREATER . class_type
  { "implementation: CLASS LIDENT COLON OPTLABEL QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND VIRTUAL WITH *)
| [_ /list(and_class_description): AND list(attribute) virtual_flag . formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND VIRTUAL WITH" }

(* implementation: CLASS LBRACKETAT AND RBRACKET WHILE *)
| [_ /structure_item: CLASS ext list(attribute) . virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT OBJECT LPAREN FALSE RPAREN WITH *)
| [_ /class_simple_expr: OBJECT list(attribute) class_self_pattern . list(text_cstr(class_field)) END]
  { "implementation: OBJECT INHERIT OBJECT LPAREN FALSE RPAREN WITH" }

(* implementation: OBJECT VAL BANG MUTABLE WITH *)
| [_ /value: BANG list(attribute) mutable_flag . LIDENT EQUAL seq_expr
     /value: BANG list(attribute) mutable_flag . LIDENT type_constraint EQUAL seq_expr]
  { "implementation: OBJECT VAL BANG MUTABLE WITH" }

(* implementation: OBJECT VAL VIRTUAL LIDENT WITH *)
| /value: list(attribute) virtual_with_mutable_flag LIDENT . COLON core_type
  { "implementation: OBJECT VAL VIRTUAL LIDENT WITH" }

(* implementation: OBJECT VAL LIDENT WITH *)
| /value: list(attribute) mutable_flag LIDENT . EQUAL seq_expr
  /value: list(attribute) mutable_flag LIDENT . type_constraint EQUAL seq_expr
  { "implementation: OBJECT VAL LIDENT WITH" }

(* implementation: OBJECT METHOD BANG PRIVATE WITH *)
| [_ /method_: BANG list(attribute) private_flag . LIDENT strict_binding
     /method_: BANG list(attribute) private_flag . LIDENT COLON possibly_poly(core_type) EQUAL seq_expr
     /method_: BANG list(attribute) private_flag . LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr]
  { "implementation: OBJECT METHOD BANG PRIVATE WITH" }

(* implementation: OBJECT METHOD VIRTUAL LIDENT WITH *)
| /method_: list(attribute) virtual_with_private_flag LIDENT . COLON possibly_poly(core_type)
  { "implementation: OBJECT METHOD VIRTUAL LIDENT WITH" }

(* implementation: OBJECT METHOD LIDENT WITH *)
| /method_: list(attribute) private_flag LIDENT . strict_binding
  /method_: list(attribute) private_flag LIDENT . COLON possibly_poly(core_type) EQUAL seq_expr
  /method_: list(attribute) private_flag LIDENT . COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD LIDENT WITH" }

(* implementation: OBJECT INITIALIZER UIDENT TYPE *)
| [_ /class_field: INITIALIZER list(attribute) seq_expr . list(post_item_attribute)]
  { "implementation: OBJECT INITIALIZER UIDENT TYPE" }

(* implementation: OBJECT INHERIT BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_field: INHERIT BANG list(attribute) . class_expr option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)]
  { "implementation: OBJECT INHERIT BANG LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT LET PERCENT AND WHILE *)
| [_ /let_bindings(no_ext): LET PERCENT attr_id . list(attribute) rec_flag let_binding_body list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET PERCENT AND WHILE" }

(* implementation: OBJECT INHERIT LET OPEN BANG WITH *)
| /class_expr: LET OPEN BANG . list(attribute) mod_longident IN class_expr
  { "implementation: OBJECT INHERIT LET OPEN BANG WITH" }

(* implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR RBRACKET WITH *)
| /class_simple_expr: LBRACKET reversed_separated_nonempty_llist(COMMA,core_type) RBRACKET . class_longident
  { "implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR RBRACKET WITH" }

(* implementation: OBJECT INHERIT LET LIDENT IN QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: let_bindings(no_ext) IN class_expr .
     /class_expr: class_expr . attribute]
  { "implementation: OBJECT INHERIT LET LIDENT IN QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT INHERIT LET OPEN LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_expr: LET OPEN list(attribute) . mod_longident IN class_expr]
  { "implementation: OBJECT INHERIT LET OPEN LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT LET REC WITH *)
| [_ /let_bindings(no_ext): LET list(attribute) rec_flag . let_binding_body list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET REC WITH" }

(* implementation: OBJECT INHERIT LPAREN LIDENT COLON WITH *)
| /class_simple_expr: LPAREN class_expr COLON . class_type RPAREN
  { "implementation: OBJECT INHERIT LPAREN LIDENT COLON WITH" }

(* implementation: OBJECT INHERIT QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: class_expr . attribute
     /class_field: INHERIT list(attribute) class_expr . option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)]
  { "implementation: OBJECT INHERIT QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /class_fun_binding: COLON class_type EQUAL . class_expr
  { "implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: CLASS LIDENT EQUAL LIDENT AND VIRTUAL WITH *)
| [_ /list(and_class_declaration): AND list(attribute) virtual_flag . formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS LIDENT EQUAL LIDENT AND VIRTUAL WITH" }

(* implementation: CLASS TYPE PERCENT AND WHILE *)
| [_ /class_type_declarations: CLASS TYPE ext . list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE PERCENT AND WHILE" }

(* implementation: CLASS LIDENT COLON OBJECT LPAREN QUOTED_STRING_EXPR RPAREN WITH *)
| [_ /class_signature: OBJECT list(attribute) class_self_type . list(text_csig(class_sig_field)) END]
  { "implementation: CLASS LIDENT COLON OBJECT LPAREN QUOTED_STRING_EXPR RPAREN WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL MUTABLE VIRTUAL WITH *)
| [_ /class_sig_field: VAL list(attribute) mutable_virtual_flags . LIDENT COLON core_type list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT VAL MUTABLE VIRTUAL WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD PRIVATE VIRTUAL WITH *)
| [_ /class_sig_field: METHOD list(attribute) private_virtual_flags . LIDENT COLON possibly_poly(core_type) list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT METHOD PRIVATE VIRTUAL WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN BANG WITH *)
| /class_signature: LET OPEN BANG . list(attribute) mod_longident IN class_signature
  { "implementation: CLASS LIDENT COLON LET OPEN BANG WITH" }

(* implementation: CLASS LIDENT COLON LBRACKET QUOTED_STRING_EXPR RBRACKET WITH *)
| /class_signature: LBRACKET reversed_separated_nonempty_llist(COMMA,core_type) RBRACKET . clty_longident
  { "implementation: CLASS LIDENT COLON LBRACKET QUOTED_STRING_EXPR RBRACKET WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_signature: LET OPEN list(attribute) . mod_longident IN class_signature]
  { "implementation: CLASS LIDENT COLON LET OPEN LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON OBJECT INHERIT LIDENT LET *)
| [_ /class_sig_field: INHERIT list(attribute) class_signature . list(post_item_attribute)
     /class_signature: class_signature . attribute]
  { "implementation: CLASS LIDENT COLON OBJECT INHERIT LIDENT LET" }

(* implementation: OBJECT CONSTRAINT QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR WITH *)
| [_ /constrain_field: core_type EQUAL core_type .
     /core_type: core_type . attribute]
  { "implementation: OBJECT CONSTRAINT QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OBJECT CONSTRAINT QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR INITIALIZER *)
| [_ /class_sig_field: CONSTRAINT list(attribute) constrain_field . list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT CONSTRAINT QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR INITIALIZER" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND VIRTUAL WITH *)
| [_ /list(and_class_type_declaration): AND list(attribute) virtual_flag . formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND VIRTUAL WITH" }

(* implementation: OBJECT LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: OBJECT ext list(attribute) . class_self_pattern list(text_cstr(class_field)) END]
  { "implementation: OBJECT LBRACKETAT AND RBRACKET WHILE" }

(* parse_pattern: LPAREN MODULE PERCENT AND WHILE *)
| [_ /simple_pattern_not_ident: LPAREN MODULE ext . list(attribute) module_name RPAREN
     /simple_pattern_not_ident: LPAREN MODULE ext . list(attribute) module_name COLON module_type RPAREN]
  { "parse_pattern: LPAREN MODULE PERCENT AND WHILE" }

(* interface: INCLUDE MODULE TYPE OF WITH *)
| /module_type: MODULE TYPE OF . list(attribute) module_expr
  { "interface: INCLUDE MODULE TYPE OF WITH" }

(* implementation: OPEN BANG PERCENT AND WHILE *)
| [_ /open_declaration: OPEN BANG ext . list(attribute) module_expr list(post_item_attribute)]
  { "implementation: OPEN BANG PERCENT AND WHILE" }

(* implementation: INCLUDE LPAREN VAL LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /paren_module_expr: LPAREN VAL list(attribute) . expr RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) . expr COLON module_type RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) . expr COLON module_type COLONGREATER module_type RPAREN
     /paren_module_expr: LPAREN VAL list(attribute) . expr COLONGREATER module_type RPAREN]
  { "implementation: INCLUDE LPAREN VAL LBRACKETAT AND RBRACKET VIRTUAL" }

(* implementation: MATCH LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /expr: MATCH ext list(attribute) . seq_expr WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: MATCH LBRACKETAT AND RBRACKET VIRTUAL" }

(* parse_any_longident: UIDENT LPAREN UIDENT WITH *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN
     /mod_ext_longident: mod_ext_longident LPAREN mod_ext_longident . RPAREN]
  { "parse_any_longident: UIDENT LPAREN UIDENT WITH" }

(* parse_core_type: OPTLABEL QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /function_type: optlabel tuple_type MINUSGREATER . function_type
  { "parse_core_type: OPTLABEL QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* parse_core_type: LBRACKET BAR QUOTED_STRING_EXPR GREATER *)
| [_ /atomic_type: LBRACKET BAR reversed_separated_nonempty_llist(BAR,row_field) . RBRACKET
     /reversed_separated_nonempty_llist(BAR,row_field): reversed_separated_nonempty_llist(BAR,row_field) . BAR row_field]
  { "parse_core_type: LBRACKET BAR QUOTED_STRING_EXPR GREATER" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT OF AMPERSAND WITH *)
| [_ /tag_field: name_tag OF opt_ampersand . reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr) list(attribute)]
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT OF AMPERSAND WITH" }

(* parse_core_type: QUOTED_STRING_EXPR AS QUOTE WITH *)
| /alias_type: alias_type AS QUOTE . ident
  { "parse_core_type: QUOTED_STRING_EXPR AS QUOTE WITH" }

(* parse_core_type: LBRACKET QUOTED_STRING_EXPR BAR WITH *)
| /atomic_type: LBRACKET row_field BAR . reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  { "parse_core_type: LBRACKET QUOTED_STRING_EXPR BAR WITH" }

(* parse_core_type: LBRACKETGREATER QUOTED_STRING_EXPR GREATER *)
| [_ /atomic_type: LBRACKETGREATER option(BAR) reversed_separated_nonempty_llist(BAR,row_field) . RBRACKET
     /reversed_separated_nonempty_llist(BAR,row_field): reversed_separated_nonempty_llist(BAR,row_field) . BAR row_field]
  { "parse_core_type: LBRACKETGREATER QUOTED_STRING_EXPR GREATER" }

(* parse_core_type: LBRACKETLESS BACKQUOTE LIDENT LBRACKETAT AND RBRACKET WHILE *)
| [_ /atomic_type: LBRACKETLESS option(BAR) reversed_separated_nonempty_llist(BAR,row_field) . RBRACKET
     /atomic_type: LBRACKETLESS option(BAR) reversed_separated_nonempty_llist(BAR,row_field) . GREATER reversed_nonempty_llist(name_tag) RBRACKET
     /reversed_separated_nonempty_llist(BAR,row_field): reversed_separated_nonempty_llist(BAR,row_field) . BAR row_field]
  { "parse_core_type: LBRACKETLESS BACKQUOTE LIDENT LBRACKETAT AND RBRACKET WHILE" }

(* parse_pattern: LAZY LBRACKETAT AND RBRACKET WHILE *)
| [_ /pattern_gen: LAZY ext list(attribute) . simple_pattern]
  { "parse_pattern: LAZY LBRACKETAT AND RBRACKET WHILE" }

(* parse_pattern: UIDENT DOT LPAREN WITH *)
| /constr_longident: mod_longident DOT LPAREN . COLONCOLON RPAREN
  /simple_pattern_not_ident: mod_longident DOT LPAREN . RPAREN
  /simple_pattern_not_ident: mod_longident DOT LPAREN . pattern RPAREN
  { "parse_pattern: UIDENT DOT LPAREN WITH" }

(* parse_pattern: EXCEPTION LBRACKETAT AND RBRACKET WHILE *)
| [_ /pattern: EXCEPTION ext list(attribute) . pattern]
  { "parse_pattern: EXCEPTION LBRACKETAT AND RBRACKET WHILE" }

(* parse_pattern: FALSE COMMA FALSE COMMA QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern_comma_list(pattern) COMMA pattern .
     /pattern_comma_list(pattern): pattern . COMMA pattern]
  { "parse_pattern: FALSE COMMA FALSE COMMA QUOTED_STRING_EXPR WHILE" }

(* parse_pattern: FALSE LPAREN TYPE WITH *)
| /pattern_gen: constr_longident LPAREN TYPE . nonempty_list(mkrhs(LIDENT)) RPAREN simple_pattern
  { "parse_pattern: FALSE LPAREN TYPE WITH" }

(* parse_pattern: LPAREN FALSE COLON WITH *)
| /simple_pattern_not_ident: LPAREN pattern COLON . core_type RPAREN
  { "parse_pattern: LPAREN FALSE COLON WITH" }

(* parse_pattern: UIDENT DOT LBRACKET WITH *)
| /simple_delimited_pattern: LBRACKET . separated_or_terminated_nonempty_list(SEMI,pattern) RBRACKET
  /simple_pattern_not_ident: mod_longident DOT LBRACKET . RBRACKET
  { "parse_pattern: UIDENT DOT LBRACKET WITH" }

(* implementation: FUN TILDE LPAREN LIDENT EQUAL *)
| [_ /labeled_simple_pattern: TILDE LPAREN label_let_pattern . RPAREN]
  { "implementation: FUN TILDE LPAREN LIDENT EQUAL" }

(* implementation: LET OPEN BANG WITH *)
| /expr: LET OPEN BANG . ext list(attribute) module_expr IN seq_expr
  { "implementation: LET OPEN BANG WITH" }

(* implementation: MODULE UIDENT LPAREN UIDENT COLON WITH *)
| /functor_arg: LPAREN module_name COLON . module_type RPAREN
  { "implementation: MODULE UIDENT LPAREN UIDENT COLON WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT WITH *)
| [_ /with_constraint: TYPE type_parameters label_longident . with_type_binder alias_type reversed_llist(preceded(CONSTRAINT,constrain))
     /with_constraint: TYPE type_parameters label_longident . COLONEQUAL alias_type]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT WITH" }

(* implementation: TYPE LIDENT CONSTRAINT QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) CONSTRAINT core_type . EQUAL core_type]
  { "implementation: TYPE LIDENT CONSTRAINT QUOTED_STRING_EXPR WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE LIDENT WHILE *)
| [_ /with_constraint: MODULE TYPE mty_longident . EQUAL module_type
     /with_constraint: MODULE TYPE mty_longident . COLONEQUAL module_type]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE LIDENT WHILE" }

(* parse_any_longident: UIDENT DOT UIDENT WHILE *)
| /ident: UIDENT .
  /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident DOT UIDENT .
  { "parse_any_longident: UIDENT DOT UIDENT WHILE" }

(* interface: INCLUDE QUOTED_STRING_EXPR MINUSGREATER QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type MINUSGREATER module_type .
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "interface: INCLUDE QUOTED_STRING_EXPR MINUSGREATER QUOTED_STRING_EXPR WHILE" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT EQUAL WITH *)
| /with_constraint: MODULE mod_longident EQUAL . mod_ext_longident
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT EQUAL WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT COLONEQUAL WITH *)
| /with_constraint: MODULE mod_longident COLONEQUAL . mod_ext_longident
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT COLONEQUAL WITH" }

(* implementation: INCLUDE LPAREN QUOTED_STRING_EXPR COLON WITH *)
| /paren_module_expr: LPAREN module_expr COLON . module_type RPAREN
  { "implementation: INCLUDE LPAREN QUOTED_STRING_EXPR COLON WITH" }

(* implementation: LAZY LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: LAZY ext list(attribute) . simple_expr]
  { "implementation: LAZY LBRACKETAT AND RBRACKET WHILE" }

(* implementation: UIDENT DOT LPAREN WITH *)
| /constr_longident: mod_longident DOT LPAREN . COLONCOLON RPAREN
  /simple_expr: mod_longident DOT LPAREN . seq_expr RPAREN
  /simple_expr: mod_longident DOT LPAREN . RPAREN
  /simple_expr: mod_longident DOT LPAREN . MODULE ext list(attribute) module_expr COLON module_type RPAREN
  /val_extra_ident: LPAREN . operator RPAREN
  { "implementation: UIDENT DOT LPAREN WITH" }

(* implementation: LETOP LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /letop_binding_body: simple_pattern COLON core_type . EQUAL seq_expr]
  { "implementation: LETOP LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: IF LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /expr: IF ext list(attribute) . seq_expr THEN expr ELSE expr
     /expr: IF ext list(attribute) . seq_expr THEN expr]
  { "implementation: IF LBRACKETAT AND RBRACKET VIRTUAL" }

(* implementation: FUNCTION LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: FUNCTION ext list(attribute) . reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: FUNCTION LBRACKETAT AND RBRACKET WHILE" }

(* implementation: FUN LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: FUN ext list(attribute) . labeled_simple_pattern fun_def
     /expr: FUN ext list(attribute) . LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN fun_def]
  { "implementation: FUN LBRACKETAT AND RBRACKET WHILE" }

(* implementation: FOR LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: FOR ext list(attribute) . pattern EQUAL seq_expr direction_flag seq_expr DO seq_expr DONE]
  { "implementation: FOR LBRACKETAT AND RBRACKET WHILE" }

(* implementation: ASSERT LBRACKETAT AND RBRACKET WHILE *)
| [_ /expr: ASSERT ext list(attribute) . simple_expr]
  { "implementation: ASSERT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: UIDENT CHAR DOTOP LPAREN WITH *)
| /simple_expr: simple_expr DOTOP LPAREN . separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  { "implementation: UIDENT CHAR DOTOP LPAREN WITH" }

(* implementation: UIDENT CHAR DOT LPAREN WITH *)
| /simple_expr: simple_expr DOT LPAREN . seq_expr RPAREN
  { "implementation: UIDENT CHAR DOT LPAREN WITH" }

(* implementation: UIDENT SEMI PERCENT UNDERSCORE *)
| /seq_expr: expr SEMI PERCENT . attr_id seq_expr
  { "implementation: UIDENT SEMI PERCENT UNDERSCORE" }

(* implementation: LETOP LIDENT LPAREN TYPE LIDENT DOT *)
| [_ /strict_binding: LPAREN TYPE nonempty_list(mkrhs(LIDENT)) . RPAREN fun_binding]
  { "implementation: LETOP LIDENT LPAREN TYPE LIDENT DOT" }

(* implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR COLONGREATER WITH *)
| /type_constraint: COLON core_type COLONGREATER . core_type
  { "implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR COLONGREATER WITH" }

(* implementation: LET LIDENT COLON TYPE WITH *)
| /let_binding_body_no_punning: val_ident COLON TYPE . nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: LET LIDENT COLON TYPE WITH" }

(* implementation: LET LIDENT COLON QUOTE LIDENT QUOTE LIDENT WITH *)
| [_ /let_binding_body_no_punning: val_ident COLON reversed_nonempty_llist(typevar) . DOT core_type EQUAL seq_expr
     /reversed_nonempty_llist(typevar): reversed_nonempty_llist(typevar) . QUOTE ident]
  { "implementation: LET LIDENT COLON QUOTE LIDENT QUOTE LIDENT WITH" }

(* implementation: LET LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /let_binding_body_no_punning: val_ident type_constraint EQUAL . seq_expr
  { "implementation: LET LIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: LET FALSE COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /let_binding_body_no_punning: simple_pattern_not_ident COLON core_type . EQUAL seq_expr]
  { "implementation: LET FALSE COLON QUOTED_STRING_EXPR WITH" }

(* implementation: LET LIDENT AND FALSE EQUAL UIDENT TO *)
| [_ /and_let_binding: AND list(attribute) let_binding_body . list(post_item_attribute)]
  { "implementation: LET LIDENT AND FALSE EQUAL UIDENT TO" }

(* implementation: UIDENT COMMA UIDENT COMMA UIDENT AS *)
| [_ /expr: expr . INFIXOP0 expr
     /expr: expr . INFIXOP1 expr
     /expr: expr . INFIXOP2 expr
     /expr: expr . INFIXOP3 expr
     /expr: expr . INFIXOP4 expr
     /expr: expr . PLUS expr
     /expr: expr . PLUSDOT expr
     /expr: expr . PLUSEQ expr
     /expr: expr . MINUS expr
     /expr: expr . MINUSDOT expr
     /expr: expr . STAR expr
     /expr: expr . PERCENT expr
     /expr: expr . EQUAL expr
     /expr: expr . LESS expr
     /expr: expr . GREATER expr
     /expr: expr . OR expr
     /expr: expr . BARBAR expr
     /expr: expr . AMPERSAND expr
     /expr: expr . AMPERAMPER expr
     /expr: expr . COLONEQUAL expr
     /expr: expr . COLONCOLON expr
     /expr: expr . attribute
     /reversed_separated_nontrivial_llist(COMMA,expr): reversed_separated_nontrivial_llist(COMMA,expr) COMMA expr .
     /reversed_separated_nontrivial_llist(COMMA,expr): expr . COMMA expr]
  { "implementation: UIDENT COMMA UIDENT COMMA UIDENT AS" }

(* implementation: UIDENT CHAR DOT LBRACKET WITH *)
| /simple_expr: simple_expr DOT LBRACKET . seq_expr RBRACKET
  { "implementation: UIDENT CHAR DOT LBRACKET WITH" }

(* implementation: UIDENT CHAR DOT LBRACE WITH *)
| /simple_expr: simple_expr DOT LBRACE . seq_expr RBRACE
  { "implementation: UIDENT CHAR DOT LBRACE WITH" }

(* implementation: UIDENT CHAR DOT UIDENT WITH *)
| [_ /mk_longident(mod_longident,LIDENT): mod_longident . DOT LIDENT
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /simple_expr: simple_expr DOT mod_longident . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr DOT mod_longident . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr DOT mod_longident . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET]
  { "implementation: UIDENT CHAR DOT UIDENT WITH" }

(* implementation: UIDENT DOTOP LPAREN WITH *)
| /expr: simple_expr DOTOP LPAREN . separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS expr
  /simple_expr: simple_expr DOTOP LPAREN . separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  { "implementation: UIDENT DOTOP LPAREN WITH" }

(* implementation: UIDENT DOTOP LBRACKET WITH *)
| /expr: simple_expr DOTOP LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS expr
  /simple_expr: simple_expr DOTOP LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: UIDENT DOTOP LBRACKET WITH" }

(* implementation: UIDENT DOTOP LBRACE WITH *)
| /expr: simple_expr DOTOP LBRACE . separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS expr
  /simple_expr: simple_expr DOTOP LBRACE . separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  { "implementation: UIDENT DOTOP LBRACE WITH" }

(* implementation: FALSE DOT LPAREN WITH *)
| /expr: simple_expr DOT LPAREN . seq_expr RPAREN LESSMINUS expr
  /simple_expr: simple_expr DOT LPAREN . seq_expr RPAREN
  { "implementation: FALSE DOT LPAREN WITH" }

(* implementation: FALSE DOT LBRACKET WITH *)
| /expr: simple_expr DOT LBRACKET . seq_expr RBRACKET LESSMINUS expr
  /simple_expr: simple_expr DOT LBRACKET . seq_expr RBRACKET
  { "implementation: FALSE DOT LBRACKET WITH" }

(* implementation: FALSE DOT LBRACE WITH *)
| /expr: simple_expr DOT LBRACE . seq_expr RBRACE LESSMINUS expr
  /simple_expr: simple_expr DOT LBRACE . seq_expr RBRACE
  { "implementation: FALSE DOT LBRACE WITH" }

(* implementation: FALSE DOT UIDENT WITH *)
| [_ /expr: simple_expr DOT mod_longident . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS expr
     /expr: simple_expr DOT mod_longident . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS expr
     /expr: simple_expr DOT mod_longident . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS expr
     /mk_longident(mod_longident,LIDENT): mod_longident . DOT LIDENT
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /simple_expr: simple_expr DOT mod_longident . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr DOT mod_longident . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr DOT mod_longident . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET]
  { "implementation: FALSE DOT UIDENT WITH" }

(* implementation: UIDENT CHAR DOTOP LBRACKET WITH *)
| /simple_expr: simple_expr DOTOP LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: UIDENT CHAR DOTOP LBRACKET WITH" }

(* implementation: UIDENT CHAR DOTOP LBRACE WITH *)
| /simple_expr: simple_expr DOTOP LBRACE . separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  { "implementation: UIDENT CHAR DOTOP LBRACE WITH" }

(* implementation: FUN FALSE LPAREN TYPE LIDENT DOT *)
| [_ /fun_def: LPAREN TYPE nonempty_list(mkrhs(LIDENT)) . RPAREN fun_def]
  { "implementation: FUN FALSE LPAREN TYPE LIDENT DOT" }

(* implementation: FUN FALSE COLON QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /fun_def: COLON atomic_type MINUSGREATER . seq_expr
  { "implementation: FUN FALSE COLON QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* implementation: FUNCTION FALSE WHEN UIDENT VAL *)
| [_ /match_case: pattern WHEN seq_expr . MINUSGREATER seq_expr]
  { "implementation: FUNCTION FALSE WHEN UIDENT VAL" }

(* implementation: LETOP LIDENT IN WITH *)
| /expr: LETOP letop_bindings IN . seq_expr
  { "implementation: LETOP LIDENT IN WITH" }

(* implementation: UIDENT DOT LBRACKETBAR WITH *)
| /simple_expr: mod_longident DOT LBRACKETBAR . separated_or_terminated_nonempty_list(SEMI,expr) BARRBRACKET
  /simple_expr: mod_longident DOT LBRACKETBAR . BARRBRACKET
  { "implementation: UIDENT DOT LBRACKETBAR WITH" }

(* implementation: UIDENT DOT LBRACKET WITH *)
| /simple_expr: mod_longident DOT LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  /simple_expr: mod_longident DOT LBRACKET . RBRACKET
  { "implementation: UIDENT DOT LBRACKET WITH" }

(* implementation: UIDENT DOT LBRACELESS WITH *)
| /simple_expr: mod_longident DOT LBRACELESS . separated_or_terminated_nonempty_list(SEMI,object_expr_field) GREATERRBRACE
  { "implementation: UIDENT DOT LBRACELESS WITH" }

(* implementation: UIDENT DOT LBRACE WITH *)
| /simple_expr: mod_longident DOT LBRACE . record_expr_content RBRACE
  { "implementation: UIDENT DOT LBRACE WITH" }

(* implementation: LBRACE LIDENT EQUAL UIDENT GREATERRBRACE *)
| [_ /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) option(preceded(EQUAL,expr)) .
     /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) option(preceded(EQUAL,expr)) . SEMI
     /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) option(preceded(EQUAL,expr)) . SEMI separated_or_terminated_nonempty_list(SEMI,record_expr_field)]
  { "implementation: LBRACE LIDENT EQUAL UIDENT GREATERRBRACE" }

(* implementation: LBRACE UIDENT DOT LIDENT WHILE *)
| /mk_longident(mod_longident,LIDENT): mod_longident DOT LIDENT .
  /val_ident: LIDENT .
  { "implementation: LBRACE UIDENT DOT LIDENT WHILE" }

(* implementation: LBRACELESS LIDENT SEMI WITH *)
| /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT option(preceded(EQUAL,expr)) SEMI .
  /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT option(preceded(EQUAL,expr)) SEMI . separated_or_terminated_nonempty_list(SEMI,object_expr_field)
  { "implementation: LBRACELESS LIDENT SEMI WITH" }

(* implementation: LET OPEN PERCENT AND WHILE *)
| [_ /expr: LET OPEN ext . list(attribute) module_expr IN seq_expr]
  { "implementation: LET OPEN PERCENT AND WHILE" }

(* implementation: LET MODULE PERCENT AND WHILE *)
| [_ /expr: LET MODULE ext . list(attribute) module_name module_binding_body IN seq_expr]
  { "implementation: LET MODULE PERCENT AND WHILE" }

(* implementation: MODULE UIDENT COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /module_binding_body: COLON module_type EQUAL . module_expr
  { "implementation: MODULE UIDENT COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: LET EXCEPTION PERCENT AND WHILE *)
| [_ /expr: LET EXCEPTION ext . list(attribute) constr_ident generalized_constructor_arguments list(attribute) IN seq_expr]
  { "implementation: LET EXCEPTION PERCENT AND WHILE" }

(* implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON WITH *)
| /label_declaration: mutable_flag LIDENT COLON . possibly_poly(core_type_no_attr) list(attribute)
  /label_declaration_semi: mutable_flag LIDENT COLON . possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute)
  { "implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON WITH" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /constructor_arguments: reversed_separated_nonempty_llist(STAR,atomic_type) STAR atomic_type .
     /reversed_separated_nonempty_llist(STAR,atomic_type): reversed_separated_nonempty_llist(STAR,atomic_type) STAR atomic_type .]
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR WHILE" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /generalized_constructor_arguments: COLON constructor_arguments MINUSGREATER . atomic_type
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* implementation: LET LBRACKETAT AND RBRACKET WHILE *)
| [_ /let_bindings(ext): LET ext list(attribute) . rec_flag let_binding_body list(post_item_attribute)]
  { "implementation: LET LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OPEN LBRACKETAT AND RBRACKET WHILE *)
| [_ /open_declaration: OPEN ext list(attribute) . module_expr list(post_item_attribute)]
  { "implementation: OPEN LBRACKETAT AND RBRACKET WHILE" }

(* implementation: MODULE TYPE PERCENT AND WHILE *)
| [_ /module_type_declaration: MODULE TYPE ext . list(attribute) ident option(preceded(EQUAL,module_type)) list(post_item_attribute)]
  { "implementation: MODULE TYPE PERCENT AND WHILE" }

(* implementation: MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /structure_item: MODULE ext list(attribute) . module_name module_binding_body list(post_item_attribute)
     /structure_item: MODULE ext list(attribute) . REC module_name module_binding_body list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND UIDENT WITH *)
| [_ /list(and_module_binding): AND list(attribute) module_name . module_binding_body list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND UIDENT WITH" }

(* implementation: LBRACKETATATAT AND QUESTION FALSE WHEN WITH *)
| /payload: QUESTION pattern WHEN . seq_expr
  { "implementation: LBRACKETATATAT AND QUESTION FALSE WHEN WITH" }

(* implementation: INCLUDE LBRACKETAT AND RBRACKET WHILE *)
| [_ /structure_item: INCLUDE ext list(attribute) . module_expr list(post_item_attribute)]
  { "implementation: INCLUDE LBRACKETAT AND RBRACKET WHILE" }

(* implementation: EXTERNAL LBRACKETAT AND RBRACKET WHILE *)
| [_ /primitive_declaration: EXTERNAL ext list(attribute) . val_ident COLON core_type EQUAL nonempty_list(raw_string) list(post_item_attribute)]
  { "implementation: EXTERNAL LBRACKETAT AND RBRACKET WHILE" }

(* implementation: EXCEPTION LBRACKETAT AND RBRACKET WHILE *)
| [_ /sig_exception_declaration: EXCEPTION ext list(attribute) . constr_ident generalized_constructor_arguments list(attribute) list(post_item_attribute)
     /str_exception_declaration: EXCEPTION ext list(attribute) . constr_ident EQUAL constr_longident list(attribute) list(post_item_attribute)]
  { "implementation: EXCEPTION LBRACKETAT AND RBRACKET WHILE" }

(* parse_constr_longident: UIDENT DOT LPAREN WITH *)
| /constr_longident: mod_longident DOT LPAREN . COLONCOLON RPAREN
  { "parse_constr_longident: UIDENT DOT LPAREN WITH" }

(* interface: OPEN BANG PERCENT AND WHILE *)
| [_ /open_description: OPEN BANG ext . list(attribute) mod_ext_longident list(post_item_attribute)]
  { "interface: OPEN BANG PERCENT AND WHILE" }

(* interface: OPEN LBRACKETAT AND RBRACKET WHILE *)
| [_ /open_description: OPEN ext list(attribute) . mod_ext_longident list(post_item_attribute)]
  { "interface: OPEN LBRACKETAT AND RBRACKET WHILE" }

(* interface: MODULE TYPE PERCENT AND WHILE *)
| [_ /module_type_declaration: MODULE TYPE ext . list(attribute) ident option(preceded(EQUAL,module_type)) list(post_item_attribute)
     /module_type_subst: MODULE TYPE ext . list(attribute) ident COLONEQUAL module_type list(post_item_attribute)]
  { "interface: MODULE TYPE PERCENT AND WHILE" }

(* interface: MODULE LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_subst: MODULE ext list(attribute) . UIDENT COLONEQUAL mod_ext_longident list(post_item_attribute)
     /signature_item: MODULE ext list(attribute) . module_name module_declaration_body list(post_item_attribute)
     /signature_item: MODULE ext list(attribute) . module_name EQUAL mod_longident list(post_item_attribute)
     /signature_item: MODULE ext list(attribute) . REC module_name COLON module_type list(post_item_attribute) list(and_module_declaration)]
  { "interface: MODULE LBRACKETAT AND RBRACKET WHILE" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT WITH *)
| [_ /list(and_module_declaration): AND list(attribute) module_name . COLON module_type list(post_item_attribute) list(and_module_declaration)]
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND UIDENT WITH" }

(* interface: INCLUDE LBRACKETAT AND RBRACKET WHILE *)
| [_ /signature_item: INCLUDE ext list(attribute) . module_type list(post_item_attribute)]
  { "interface: INCLUDE LBRACKETAT AND RBRACKET WHILE" }

(* interface: EXCEPTION LBRACKETAT AND RBRACKET WHILE *)
| [_ /sig_exception_declaration: EXCEPTION ext list(attribute) . constr_ident generalized_constructor_arguments list(attribute) list(post_item_attribute)]
  { "interface: EXCEPTION LBRACKETAT AND RBRACKET WHILE" }

(* implementation: TYPE LIDENT AND UNDERSCORE WITH *)
| [_ /list(generic_and_type_declaration(type_kind)): AND list(attribute) type_parameters . LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_kind))]
  { "implementation: TYPE LIDENT AND UNDERSCORE WITH" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND UNDERSCORE WITH *)
| [_ /list(generic_and_type_declaration(type_subst_kind)): AND list(attribute) type_parameters . LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_subst_kind))]
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND UNDERSCORE WITH" }

(* implementation: TYPE LIDENT EQUAL BAR FALSE COLON QUOTED_STRING_EXPR IN *)
| [_ /generic_constructor_declaration(BAR): BAR constr_ident generalized_constructor_arguments . list(attribute)]
  { "implementation: TYPE LIDENT EQUAL BAR FALSE COLON QUOTED_STRING_EXPR IN" }

(* implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL PRIVATE WITH *)
| /nonempty_type_kind: core_type EQUAL PRIVATE . constructor_declarations
  /nonempty_type_kind: core_type EQUAL PRIVATE . DOTDOT
  /nonempty_type_kind: core_type EQUAL PRIVATE . LBRACE label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL PRIVATE WITH" }

(* implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL LBRACE WITH *)
| /nonempty_type_kind: core_type EQUAL LBRACE . label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL LBRACE WITH" }

(* implementation: LBRACKETATATAT AND SEMISEMI END *)
| [_ /floating_attribute: LBRACKETATATAT attr_id payload . RBRACKET]
  { "implementation: LBRACKETATATAT AND SEMISEMI END" }

(* implementation: LBRACKETPERCENTPERCENT AND SEMISEMI END *)
| [_ /item_extension: LBRACKETPERCENTPERCENT attr_id payload . RBRACKET]
  { "implementation: LBRACKETPERCENTPERCENT AND SEMISEMI END" }

(* implementation: SEMISEMI UIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /list(structure_element): SEMISEMI seq_expr list(post_item_attribute) . list(structure_element)]
  { "implementation: SEMISEMI UIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: INCLUDE STRUCT SEMISEMI EOF *)
| [_ /module_expr: STRUCT list(attribute) structure . END]
  { "implementation: INCLUDE STRUCT SEMISEMI EOF" }

(* implementation: OBJECT LPAREN FALSE COLON WITH *)
| /class_self_pattern: LPAREN pattern COLON . core_type RPAREN
  { "implementation: OBJECT LPAREN FALSE COLON WITH" }

(* implementation: LPAREN MODULE PERCENT AND WHILE *)
| [_ /simple_expr: LPAREN MODULE ext . list(attribute) module_expr RPAREN
     /simple_expr: LPAREN MODULE ext . list(attribute) module_expr COLON module_type RPAREN]
  { "implementation: LPAREN MODULE PERCENT AND WHILE" }

(* implementation: LPAREN UIDENT COLON QUOTED_STRING_EXPR RBRACE *)
| [_ /simple_expr: LPAREN seq_expr type_constraint . RPAREN]
  { "implementation: LPAREN UIDENT COLON QUOTED_STRING_EXPR RBRACE" }

(* implementation: QUOTED_STRING_ITEM LBRACKETATAT AND SEMISEMI END *)
| [_ /post_item_attribute: LBRACKETATAT attr_id payload . RBRACKET]
  { "implementation: QUOTED_STRING_ITEM LBRACKETATAT AND SEMISEMI END" }

(* implementation: TYPE LIDENT PLUSEQ BAR FALSE EQUAL WITH *)
| /extension_constructor_rebind(BAR): BAR constr_ident EQUAL . constr_longident list(attribute)
  { "implementation: TYPE LIDENT PLUSEQ BAR FALSE EQUAL WITH" }

(* implementation: TYPE LIDENT PLUSEQ FALSE EQUAL FALSE WITH *)
| [_ /extension_constructor_rebind(epsilon): constr_ident EQUAL constr_longident . list(attribute)]
  { "implementation: TYPE LIDENT PLUSEQ FALSE EQUAL FALSE WITH" }

(* implementation: LBRACKETPERCENT AND SEMISEMI END *)
| [_ /extension: LBRACKETPERCENT attr_id payload . RBRACKET]
  { "implementation: LBRACKETPERCENT AND SEMISEMI END" }

(* parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR RBRACE *)
| [_ /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) . list(attribute) SEMI list(attribute) meth_list
     /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) . list(attribute) SEMI list(attribute)
     /meth_list: LIDENT COLON possibly_poly(core_type_no_attr) . list(attribute)]
  { "parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR RBRACE" }

(* parse_core_type: LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /function_type: LIDENT COLON tuple_type . MINUSGREATER function_type]
  { "parse_core_type: LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR RPAREN WITH *)
| /atomic_type: LPAREN reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN . type_longident
  /atomic_type: LPAREN reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN . HASH clty_longident
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR RPAREN WITH" }

(* interface: INCLUDE SIG SEMISEMI EOF *)
| [_ /module_type: SIG list(attribute) signature . END]
  { "interface: INCLUDE SIG SEMISEMI EOF" }

(* implementation: UIDENT LBRACKETAT AND SEMISEMI END *)
| [_ /attribute: LBRACKETAT attr_id payload . RBRACKET]
  { "implementation: UIDENT LBRACKETAT AND SEMISEMI END" }

(* implementation: WHILE LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /expr: WHILE ext list(attribute) . seq_expr DO seq_expr DONE]
  { "implementation: WHILE LBRACKETAT AND RBRACKET VIRTUAL" }

(* interface: TYPE PERCENT AND WHILE *)
| [_ /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext . list(attribute) type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE ext . list(attribute) NONREC type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext . list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext . list(attribute) NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /signature_item: TYPE ext . list(attribute) type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
     /signature_item: TYPE ext . list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)]
  { "interface: TYPE PERCENT AND WHILE" }

(* toplevel_phrase: HASH LIDENT WITH *)
| [_ /toplevel_directive: HASH ident .
     /toplevel_directive: HASH ident . STRING
     /toplevel_directive: HASH ident . INT
     /toplevel_directive: HASH ident . val_longident
     /toplevel_directive: HASH ident . mod_longident
     /toplevel_directive: HASH ident . FALSE
     /toplevel_directive: HASH ident . TRUE]
  { "toplevel_phrase: HASH LIDENT WITH" }

(* parse_any_longident: UIDENT DOT WITH *)
| /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident DOT . UIDENT
  /mk_longident(mod_ext_longident,__anonymous_41): mod_ext_longident DOT . ident
  /mk_longident(mod_ext_longident,__anonymous_41): mod_ext_longident DOT . LPAREN COLONCOLON RPAREN
  /mk_longident(mod_ext_longident,__anonymous_41): mod_ext_longident DOT . val_extra_ident
  { "parse_any_longident: UIDENT DOT WITH" }

(* implementation: TYPE PERCENT AND WHILE *)
| [_ /generic_type_declaration(nonrec_flag,type_kind): TYPE ext . list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /generic_type_declaration(nonrec_flag,type_kind): TYPE ext . list(attribute) NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
     /structure_item: TYPE ext . list(attribute) type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
     /structure_item: TYPE ext . list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)]
  { "implementation: TYPE PERCENT AND WHILE" }

(* implementation: ASSERT PERCENT AND WHILE *)
| [_ /expr: ASSERT ext . list(attribute) simple_expr]
  { "implementation: ASSERT PERCENT AND WHILE" }

(* implementation: BEGIN PERCENT AND VIRTUAL *)
| [_ /simple_expr: BEGIN ext . list(attribute) seq_expr END
     /simple_expr: BEGIN ext . list(attribute) END]
  { "implementation: BEGIN PERCENT AND VIRTUAL" }

(* implementation: LBRACKETATATAT AND DOT UNDERSCORE *)
| /attr_id: single_attr_id DOT . attr_id
  { "implementation: LBRACKETATATAT AND DOT UNDERSCORE" }

(* implementation: WHILE PERCENT AND VIRTUAL *)
| [_ /expr: WHILE ext . list(attribute) seq_expr DO seq_expr DONE]
  { "implementation: WHILE PERCENT AND VIRTUAL" }

(* implementation: UIDENT LBRACKETAT AND VIRTUAL *)
| [_ /attribute: LBRACKETAT attr_id . payload RBRACKET]
  { "implementation: UIDENT LBRACKETAT AND VIRTUAL" }

(* implementation: VAL PERCENT AND WHILE *)
| [_ /value_description: VAL ext . list(attribute) val_ident COLON core_type list(post_item_attribute)]
  { "implementation: VAL PERCENT AND WHILE" }

(* implementation: LPAREN DOTOP LPAREN WITH *)
| /operator: DOTOP LPAREN . index_mod RPAREN
  /operator: DOTOP LPAREN . index_mod RPAREN LESSMINUS
  { "implementation: LPAREN DOTOP LPAREN WITH" }

(* implementation: LPAREN DOTOP LBRACKET WITH *)
| /operator: DOTOP LBRACKET . index_mod RBRACKET
  /operator: DOTOP LBRACKET . index_mod RBRACKET LESSMINUS
  { "implementation: LPAREN DOTOP LBRACKET WITH" }

(* implementation: LPAREN DOTOP LBRACE WITH *)
| /operator: DOTOP LBRACE . index_mod RBRACE
  /operator: DOTOP LBRACE . index_mod RBRACE LESSMINUS
  { "implementation: LPAREN DOTOP LBRACE WITH" }

(* implementation: LPAREN AMPERAMPER WITH *)
| [_ /val_extra_ident: LPAREN operator . RPAREN]
  { "implementation: LPAREN AMPERAMPER WITH" }

(* parse_core_type: QUESTION LIDENT WITH *)
| /optlabel: QUESTION LIDENT . COLON
  { "parse_core_type: QUESTION LIDENT WITH" }

(* parse_core_type: LPAREN MODULE WITH *)
| /atomic_type: LPAREN MODULE . ext list(attribute) module_type RPAREN
  { "parse_core_type: LPAREN MODULE WITH" }

(* interface: INCLUDE SIG LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_type: SIG list(attribute) . signature END]
  { "interface: INCLUDE SIG LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LBRACKET UNDERSCORE WITH *)
| [_ /formal_class_parameters: LBRACKET reversed_separated_nonempty_llist(COMMA,type_parameter) . RBRACKET
     /reversed_separated_nonempty_llist(COMMA,type_parameter): reversed_separated_nonempty_llist(COMMA,type_parameter) . COMMA type_parameter]
  { "implementation: CLASS LBRACKET UNDERSCORE WITH" }

(* implementation: TYPE LPAREN UNDERSCORE WITH *)
| [_ /reversed_separated_nonempty_llist(COMMA,type_parameter): reversed_separated_nonempty_llist(COMMA,type_parameter) . COMMA type_parameter
     /type_parameters: LPAREN reversed_separated_nonempty_llist(COMMA,type_parameter) . RPAREN]
  { "implementation: TYPE LPAREN UNDERSCORE WITH" }

(* implementation: TYPE LPAREN UNDERSCORE COMMA WITH *)
| /reversed_separated_nonempty_llist(COMMA,type_parameter): reversed_separated_nonempty_llist(COMMA,type_parameter) COMMA . type_parameter
  { "implementation: TYPE LPAREN UNDERSCORE COMMA WITH" }

(* parse_core_type: LIDENT COLON WITH *)
| /function_type: LIDENT COLON . tuple_type MINUSGREATER function_type
  { "parse_core_type: LIDENT COLON WITH" }

(* parse_core_type: LESS LIDENT COLON WITH *)
| /meth_list: LIDENT COLON . possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute) meth_list
  /meth_list: LIDENT COLON . possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute)
  /meth_list: LIDENT COLON . possibly_poly(core_type_no_attr) list(attribute)
  { "parse_core_type: LESS LIDENT COLON WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTE LIDENT WITH *)
| [_ /atomic_type: QUOTE ident .
     /reversed_nonempty_llist(typevar): QUOTE ident .]
  { "parse_core_type: LESS LIDENT COLON QUOTE LIDENT WITH" }

(* implementation: LBRACKETPERCENT AND VIRTUAL *)
| [_ /extension: LBRACKETPERCENT attr_id . payload RBRACKET]
  { "implementation: LBRACKETPERCENT AND VIRTUAL" }

(* implementation: QUOTED_STRING_ITEM LBRACKETATAT AND VIRTUAL *)
| [_ /post_item_attribute: LBRACKETATAT attr_id . payload RBRACKET]
  { "implementation: QUOTED_STRING_ITEM LBRACKETATAT AND VIRTUAL" }

(* implementation: TRY PERCENT AND VIRTUAL *)
| [_ /expr: TRY ext . list(attribute) seq_expr WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: TRY PERCENT AND VIRTUAL" }

(* implementation: NEW PERCENT AND WHILE *)
| [_ /simple_expr: NEW ext . list(attribute) class_longident]
  { "implementation: NEW PERCENT AND WHILE" }

(* parse_pattern: LBRACE UIDENT DOT WITH *)
| /mk_longident(mod_longident,LIDENT): mod_longident DOT . LIDENT
  /mk_longident(mod_longident,UIDENT): mod_longident DOT . UIDENT
  { "parse_pattern: LBRACE UIDENT DOT WITH" }

(* interface: CLASS PERCENT AND WHILE *)
| [_ /signature_item: CLASS ext . list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS PERCENT AND WHILE" }

(* implementation: CLASS LIDENT COLON LIDENT COLON WITH *)
| /class_type: LIDENT COLON . tuple_type MINUSGREATER class_type
  { "implementation: CLASS LIDENT COLON LIDENT COLON WITH" }

(* implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /class_type: tuple_type MINUSGREATER . class_type
  { "implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* implementation: CLASS LIDENT COLON OPTLABEL QUOTED_STRING_EXPR WITH *)
| [_ /class_type: optlabel tuple_type . MINUSGREATER class_type]
  { "implementation: CLASS LIDENT COLON OPTLABEL QUOTED_STRING_EXPR WITH" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(and_class_description): AND list(attribute) . virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)]
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS PERCENT AND WHILE *)
| [_ /structure_item: CLASS ext . list(attribute) virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS PERCENT AND WHILE" }

(* implementation: OBJECT INHERIT OBJECT LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_simple_expr: OBJECT list(attribute) . class_self_pattern list(text_cstr(class_field)) END]
  { "implementation: OBJECT INHERIT OBJECT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT VAL BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /value: BANG list(attribute) . mutable_flag LIDENT EQUAL seq_expr
     /value: BANG list(attribute) . mutable_flag LIDENT type_constraint EQUAL seq_expr]
  { "implementation: OBJECT VAL BANG LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT VAL LIDENT EQUAL UIDENT TYPE *)
| [_ /class_field: VAL value . list(post_item_attribute)]
  { "implementation: OBJECT VAL LIDENT EQUAL UIDENT TYPE" }

(* implementation: OBJECT VAL MUTABLE VIRTUAL WITH *)
| [_ /value: list(attribute) virtual_with_mutable_flag . LIDENT COLON core_type]
  { "implementation: OBJECT VAL MUTABLE VIRTUAL WITH" }

(* implementation: OBJECT METHOD BANG LBRACKETAT AND RBRACKET WHILE *)
| [_ /method_: BANG list(attribute) . private_flag LIDENT strict_binding
     /method_: BANG list(attribute) . private_flag LIDENT COLON possibly_poly(core_type) EQUAL seq_expr
     /method_: BANG list(attribute) . private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr]
  { "implementation: OBJECT METHOD BANG LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT METHOD LIDENT EQUAL UIDENT TYPE *)
| [_ /class_field: METHOD method_ . list(post_item_attribute)]
  { "implementation: OBJECT METHOD LIDENT EQUAL UIDENT TYPE" }

(* implementation: OBJECT METHOD PRIVATE VIRTUAL WITH *)
| [_ /method_: list(attribute) virtual_with_private_flag . LIDENT COLON possibly_poly(core_type)]
  { "implementation: OBJECT METHOD PRIVATE VIRTUAL WITH" }

(* implementation: OBJECT INITIALIZER LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /class_field: INITIALIZER list(attribute) . seq_expr list(post_item_attribute)]
  { "implementation: OBJECT INITIALIZER LBRACKETAT AND RBRACKET VIRTUAL" }

(* implementation: OBJECT INHERIT BANG WITH *)
| /class_field: INHERIT BANG . list(attribute) class_expr option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)
  { "implementation: OBJECT INHERIT BANG WITH" }

(* implementation: OBJECT INHERIT LET PERCENT UNDERSCORE *)
| /let_bindings(no_ext): LET PERCENT . attr_id list(attribute) rec_flag let_binding_body list(post_item_attribute)
  { "implementation: OBJECT INHERIT LET PERCENT UNDERSCORE" }

(* implementation: OBJECT INHERIT LET OPEN WITH *)
| /class_expr: LET OPEN . list(attribute) mod_longident IN class_expr
  /class_expr: LET OPEN . BANG list(attribute) mod_longident IN class_expr
  { "implementation: OBJECT INHERIT LET OPEN WITH" }

(* implementation: OBJECT INHERIT FUN LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_expr: FUN list(attribute) . class_fun_def]
  { "implementation: OBJECT INHERIT FUN LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT FUN FALSE MINUSGREATER WITH *)
| /class_fun_def: labeled_simple_pattern MINUSGREATER . class_expr
  { "implementation: OBJECT INHERIT FUN FALSE MINUSGREATER WITH" }

(* implementation: OBJECT INHERIT LET LIDENT IN WITH *)
| /class_expr: let_bindings(no_ext) IN . class_expr
  { "implementation: OBJECT INHERIT LET LIDENT IN WITH" }

(* implementation: OBJECT INHERIT LIDENT CHAR TO *)
| [_ /class_expr: class_simple_expr reversed_nonempty_llist(labeled_simple_expr) .
     /reversed_nonempty_llist(labeled_simple_expr): reversed_nonempty_llist(labeled_simple_expr) . labeled_simple_expr]
  { "implementation: OBJECT INHERIT LIDENT CHAR TO" }

(* implementation: OBJECT INHERIT LET LBRACKETAT AND RBRACKET WHILE *)
| [_ /let_bindings(no_ext): LET list(attribute) . rec_flag let_binding_body list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LET LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT INHERIT LPAREN QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: class_expr . attribute
     /class_simple_expr: LPAREN class_expr . RPAREN
     /class_simple_expr: LPAREN class_expr . COLON class_type RPAREN]
  { "implementation: OBJECT INHERIT LPAREN QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT INHERIT LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_field: INHERIT list(attribute) . class_expr option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)]
  { "implementation: OBJECT INHERIT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT CONSTRAINT LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_field: CONSTRAINT list(attribute) . constrain_field list(post_item_attribute)]
  { "implementation: OBJECT CONSTRAINT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR VAL *)
| [_ /class_fun_binding: COLON class_type . EQUAL class_expr]
  { "implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR VAL" }

(* implementation: CLASS LIDENT EQUAL LIDENT AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(and_class_declaration): AND list(attribute) . virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)]
  { "implementation: CLASS LIDENT EQUAL LIDENT AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS TYPE WITH *)
| /class_type_declarations: CLASS TYPE . ext list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)
  { "implementation: CLASS TYPE WITH" }

(* implementation: CLASS LIDENT COLON OBJECT LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_signature: OBJECT list(attribute) . class_self_type list(text_csig(class_sig_field)) END]
  { "implementation: CLASS LIDENT COLON OBJECT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON OBJECT LPAREN QUOTED_STRING_EXPR WITH *)
| [_ /class_self_type: LPAREN core_type . RPAREN
     /core_type: core_type . attribute]
  { "implementation: CLASS LIDENT COLON OBJECT LPAREN QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_sig_field: VAL list(attribute) . mutable_virtual_flags LIDENT COLON core_type list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT VAL LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_sig_field: METHOD list(attribute) . private_virtual_flags LIDENT COLON possibly_poly(core_type) list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT METHOD LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT METHOD LIDENT COLON QUOTE LIDENT DOT WITH *)
| /possibly_poly(core_type): reversed_nonempty_llist(typevar) DOT . core_type
  { "implementation: OBJECT METHOD LIDENT COLON QUOTE LIDENT DOT WITH" }

(* implementation: CLASS LIDENT COLON OBJECT INHERIT LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_sig_field: INHERIT list(attribute) . class_signature list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT INHERIT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: CLASS LIDENT COLON LET OPEN WITH *)
| /class_signature: LET OPEN . list(attribute) mod_longident IN class_signature
  /class_signature: LET OPEN . BANG list(attribute) mod_longident IN class_signature
  { "implementation: CLASS LIDENT COLON LET OPEN WITH" }

(* implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR COMMA WITH *)
| /reversed_separated_nonempty_llist(COMMA,core_type): reversed_separated_nonempty_llist(COMMA,core_type) COMMA . core_type
  { "implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR COMMA WITH" }

(* implementation: CLASS LIDENT COLON OBJECT CONSTRAINT LBRACKETAT AND RBRACKET WHILE *)
| [_ /class_sig_field: CONSTRAINT list(attribute) . constrain_field list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT CONSTRAINT LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT CONSTRAINT QUOTED_STRING_EXPR EQUAL WITH *)
| /constrain_field: core_type EQUAL . core_type
  { "implementation: OBJECT CONSTRAINT QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(and_class_type_declaration): AND list(attribute) . virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)]
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT PERCENT AND WHILE *)
| [_ /expr: OBJECT ext . list(attribute) class_self_pattern list(text_cstr(class_field)) END]
  { "implementation: OBJECT PERCENT AND WHILE" }

(* parse_pattern: LPAREN MODULE WITH *)
| /simple_pattern_not_ident: LPAREN MODULE . ext list(attribute) module_name RPAREN
  /simple_pattern_not_ident: LPAREN MODULE . ext list(attribute) module_name COLON module_type RPAREN
  { "parse_pattern: LPAREN MODULE WITH" }

(* interface: INCLUDE MODULE TYPE WITH *)
| /module_type: MODULE TYPE . OF list(attribute) module_expr
  { "interface: INCLUDE MODULE TYPE WITH" }

(* implementation: INCLUDE STRUCT LBRACKETAT AND RBRACKET VIRTUAL *)
| [_ /module_expr: STRUCT list(attribute) . structure END]
  { "implementation: INCLUDE STRUCT LBRACKETAT AND RBRACKET VIRTUAL" }

(* implementation: OPEN BANG WITH *)
| /open_declaration: OPEN BANG . ext list(attribute) module_expr list(post_item_attribute)
  { "implementation: OPEN BANG WITH" }

(* implementation: INCLUDE LPAREN VAL WITH *)
| /paren_module_expr: LPAREN VAL . list(attribute) expr RPAREN
  /paren_module_expr: LPAREN VAL . list(attribute) expr COLON module_type RPAREN
  /paren_module_expr: LPAREN VAL . list(attribute) expr COLON module_type COLONGREATER module_type RPAREN
  /paren_module_expr: LPAREN VAL . list(attribute) expr COLONGREATER module_type RPAREN
  { "implementation: INCLUDE LPAREN VAL WITH" }

(* implementation: MATCH PERCENT AND VIRTUAL *)
| [_ /expr: MATCH ext . list(attribute) seq_expr WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: MATCH PERCENT AND VIRTUAL" }

(* implementation: LIDENT LESSMINUS WITH *)
| /expr: LIDENT LESSMINUS . expr
  { "implementation: LIDENT LESSMINUS WITH" }

(* parse_pattern: LBRACE LIDENT SEMI UNDERSCORE SEMI WITH *)
| [_ /simple_delimited_pattern: LBRACE listx(SEMI,record_pat_field,UNDERSCORE) . RBRACE]
  { "parse_pattern: LBRACE LIDENT SEMI UNDERSCORE SEMI WITH" }

(* parse_core_type: LBRACKETLESS BAR WITH *)
| [_ /atomic_type: LBRACKETLESS option(BAR) . reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
     /atomic_type: LBRACKETLESS option(BAR) . reversed_separated_nonempty_llist(BAR,row_field) GREATER reversed_nonempty_llist(name_tag) RBRACKET]
  { "parse_core_type: LBRACKETLESS BAR WITH" }

(* parse_core_type: LBRACKETGREATER BAR WITH *)
| [_ /atomic_type: LBRACKETGREATER option(BAR) . reversed_separated_nonempty_llist(BAR,row_field) RBRACKET]
  { "parse_core_type: LBRACKETGREATER BAR WITH" }

(* parse_any_longident: UIDENT LPAREN WITH *)
| /mod_ext_longident: mod_ext_longident LPAREN . mod_ext_longident RPAREN
  { "parse_any_longident: UIDENT LPAREN WITH" }

(* parse_mod_ext_longident: UIDENT DOT WITH *)
| /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident DOT . UIDENT
  { "parse_mod_ext_longident: UIDENT DOT WITH" }

(* parse_core_type: UIDENT DOT WITH *)
| /mk_longident(mod_ext_longident,LIDENT): mod_ext_longident DOT . LIDENT
  /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident DOT . UIDENT
  { "parse_core_type: UIDENT DOT WITH" }

(* parse_core_type: LBRACKET BAR WITH *)
| /atomic_type: LBRACKET BAR . reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  { "parse_core_type: LBRACKET BAR WITH" }

(* parse_core_type: QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /function_type: tuple_type MINUSGREATER . function_type
  { "parse_core_type: QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* parse_core_type: QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR STAR WITH *)
| /reversed_separated_nontrivial_llist(STAR,atomic_type): reversed_separated_nontrivial_llist(STAR,atomic_type) STAR . atomic_type
  { "parse_core_type: QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR STAR WITH" }

(* parse_core_type: QUOTED_STRING_EXPR HASH WITH *)
| /atomic_type: atomic_type HASH . clty_longident
  { "parse_core_type: QUOTED_STRING_EXPR HASH WITH" }

(* parse_core_type: OPTLABEL QUOTED_STRING_EXPR WITH *)
| [_ /function_type: optlabel tuple_type . MINUSGREATER function_type]
  { "parse_core_type: OPTLABEL QUOTED_STRING_EXPR WITH" }

(* parse_core_type: QUOTED_STRING_EXPR STAR WITH *)
| /reversed_separated_nontrivial_llist(STAR,atomic_type): atomic_type STAR . atomic_type
  { "parse_core_type: QUOTED_STRING_EXPR STAR WITH" }

(* parse_core_type: LBRACKETGREATER QUOTED_STRING_EXPR BAR WITH *)
| /reversed_separated_nonempty_llist(BAR,row_field): reversed_separated_nonempty_llist(BAR,row_field) BAR . row_field
  { "parse_core_type: LBRACKETGREATER QUOTED_STRING_EXPR BAR WITH" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT OF WITH *)
| /tag_field: name_tag OF . opt_ampersand reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr) list(attribute)
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT OF WITH" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT OF QUOTED_STRING_EXPR AMPERSAND WITH *)
| /reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr): reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr) AMPERSAND . alias_type
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT OF QUOTED_STRING_EXPR AMPERSAND WITH" }

(* parse_core_type: QUOTED_STRING_EXPR AS WITH *)
| /alias_type: alias_type AS . QUOTE ident
  { "parse_core_type: QUOTED_STRING_EXPR AS WITH" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT GREATER *)
| [_ /atomic_type: LBRACKET tag_field . RBRACKET
     /row_field: tag_field .]
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT GREATER" }

(* parse_core_type: LBRACKET QUOTED_STRING_EXPR RBRACKET *)
| [_ /atomic_type: LBRACKET row_field . BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET]
  { "parse_core_type: LBRACKET QUOTED_STRING_EXPR RBRACKET" }

(* parse_pattern: LAZY PERCENT AND WHILE *)
| [_ /pattern_gen: LAZY ext . list(attribute) simple_pattern]
  { "parse_pattern: LAZY PERCENT AND WHILE" }

(* parse_pattern: CHAR DOTDOT WITH *)
| /simple_pattern_not_ident: signed_constant DOTDOT . signed_constant
  { "parse_pattern: CHAR DOTDOT WITH" }

(* parse_pattern: UIDENT DOT WITH *)
| /constr_longident: mod_longident DOT . LPAREN COLONCOLON RPAREN
  /mk_longident(mod_longident,UIDENT): mod_longident DOT . UIDENT
  /simple_pattern_not_ident: mod_longident DOT . simple_delimited_pattern
  /simple_pattern_not_ident: mod_longident DOT . LBRACKET RBRACKET
  /simple_pattern_not_ident: mod_longident DOT . LPAREN RPAREN
  /simple_pattern_not_ident: mod_longident DOT . LPAREN pattern RPAREN
  { "parse_pattern: UIDENT DOT WITH" }

(* parse_pattern: EXCEPTION PERCENT AND WHILE *)
| [_ /pattern: EXCEPTION ext . list(attribute) pattern]
  { "parse_pattern: EXCEPTION PERCENT AND WHILE" }

(* parse_pattern: FALSE COMMA FALSE COMMA WITH *)
| /pattern_comma_list(pattern): pattern_comma_list(pattern) COMMA . pattern
  { "parse_pattern: FALSE COMMA FALSE COMMA WITH" }

(* parse_pattern: FALSE COLONCOLON WITH *)
| /pattern: pattern COLONCOLON . pattern
  { "parse_pattern: FALSE COLONCOLON WITH" }

(* parse_pattern: FALSE LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  /pattern_gen: constr_longident LPAREN . TYPE nonempty_list(mkrhs(LIDENT)) RPAREN simple_pattern
  /simple_pattern_not_ident: LPAREN . pattern RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name COLON module_type RPAREN
  /simple_pattern_not_ident: LPAREN . pattern COLON core_type RPAREN
  /val_extra_ident: LPAREN . operator RPAREN
  { "parse_pattern: FALSE LPAREN WITH" }

(* implementation: LPAREN COLONCOLON WITH *)
| /constr_longident: LPAREN COLONCOLON . RPAREN
  { "implementation: LPAREN COLONCOLON WITH" }

(* parse_pattern: LPAREN QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /simple_pattern_not_ident: LPAREN pattern . RPAREN
     /simple_pattern_not_ident: LPAREN pattern . COLON core_type RPAREN]
  { "parse_pattern: LPAREN QUOTED_STRING_EXPR WHILE" }

(* parse_pattern: FALSE COMMA WITH *)
| /pattern_comma_list(pattern): pattern COMMA . pattern
  { "parse_pattern: FALSE COMMA WITH" }

(* parse_pattern: FALSE BAR WITH *)
| /pattern: pattern BAR . pattern
  { "parse_pattern: FALSE BAR WITH" }

(* parse_pattern: FALSE AS WITH *)
| /pattern: pattern AS . val_ident
  { "parse_pattern: FALSE AS WITH" }

(* parse_pattern: LBRACKET FALSE BARRBRACKET *)
| [_ /simple_delimited_pattern: LBRACKET separated_or_terminated_nonempty_list(SEMI,pattern) . RBRACKET]
  { "parse_pattern: LBRACKET FALSE BARRBRACKET" }

(* parse_pattern: LBRACKET FALSE SEMI WITH *)
| /separated_or_terminated_nonempty_list(SEMI,pattern): pattern SEMI .
  /separated_or_terminated_nonempty_list(SEMI,pattern): pattern SEMI . separated_or_terminated_nonempty_list(SEMI,pattern)
  { "parse_pattern: LBRACKET FALSE SEMI WITH" }

(* parse_pattern: LBRACE LIDENT EQUAL QUOTED_STRING_EXPR WHILE *)
| [_ /option(preceded(EQUAL,pattern)): EQUAL pattern .
     /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern]
  { "parse_pattern: LBRACE LIDENT EQUAL QUOTED_STRING_EXPR WHILE" }

(* parse_pattern: LBRACKETBAR FALSE RBRACKET *)
| [_ /simple_delimited_pattern: LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,pattern) . BARRBRACKET]
  { "parse_pattern: LBRACKETBAR FALSE RBRACKET" }

(* implementation: FUN TILDE LPAREN WITH *)
| /labeled_simple_pattern: TILDE LPAREN . label_let_pattern RPAREN
  { "implementation: FUN TILDE LPAREN WITH" }

(* implementation: FUN QUESTION LPAREN LIDENT COLON WITH *)
| /label_let_pattern: LIDENT COLON . core_type
  { "implementation: FUN QUESTION LPAREN LIDENT COLON WITH" }

(* implementation: FUN QUESTION LPAREN WITH *)
| /labeled_simple_pattern: QUESTION LPAREN . label_let_pattern option(preceded(EQUAL,seq_expr)) RPAREN
  { "implementation: FUN QUESTION LPAREN WITH" }

(* implementation: LET OPEN WITH *)
| /expr: LET OPEN . ext list(attribute) module_expr IN seq_expr
  /expr: LET OPEN . BANG ext list(attribute) module_expr IN seq_expr
  { "implementation: LET OPEN WITH" }

(* implementation: INCLUDE FUNCTOR LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_expr: FUNCTOR list(attribute) . functor_args MINUSGREATER module_expr]
  { "implementation: INCLUDE FUNCTOR LBRACKETAT AND RBRACKET WHILE" }

(* implementation: MODULE UIDENT LPAREN UIDENT WITH *)
| [_ /functor_arg: LPAREN module_name . COLON module_type RPAREN]
  { "implementation: MODULE UIDENT LPAREN UIDENT WITH" }

(* interface: INCLUDE FUNCTOR LBRACKETAT AND RBRACKET WHILE *)
| [_ /module_type: FUNCTOR list(attribute) . functor_args MINUSGREATER module_type]
  { "interface: INCLUDE FUNCTOR LBRACKETAT AND RBRACKET WHILE" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH WITH *)
| /module_type: module_type WITH . reversed_separated_nonempty_llist(AND,with_constraint)
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE UNDERSCORE WITH *)
| [_ /with_constraint: TYPE type_parameters . label_longident with_type_binder alias_type reversed_llist(preceded(CONSTRAINT,constrain))
     /with_constraint: TYPE type_parameters . label_longident COLONEQUAL alias_type]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE UNDERSCORE WITH" }

(* implementation: TYPE LIDENT CONSTRAINT WITH *)
| /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) CONSTRAINT . core_type EQUAL core_type
  { "implementation: TYPE LIDENT CONSTRAINT WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE WITH *)
| /with_constraint: MODULE TYPE . mty_longident EQUAL module_type
  /with_constraint: MODULE TYPE . mty_longident COLONEQUAL module_type
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE WITH" }

(* parse_mty_longident: UIDENT DOT WITH *)
| /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident DOT . UIDENT
  /mk_longident(mod_ext_longident,ident): mod_ext_longident DOT . ident
  { "parse_mty_longident: UIDENT DOT WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR MINUSGREATER WITH *)
| /module_type: module_type MINUSGREATER . module_type
  { "interface: INCLUDE QUOTED_STRING_EXPR MINUSGREATER WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT WITH *)
| [_ /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /with_constraint: MODULE mod_longident . EQUAL mod_ext_longident
     /with_constraint: MODULE mod_longident . COLONEQUAL mod_ext_longident]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT WITH" }

(* parse_mod_longident: UIDENT DOT WITH *)
| /mk_longident(mod_longident,UIDENT): mod_longident DOT . UIDENT
  { "parse_mod_longident: UIDENT DOT WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT COLONEQUAL UIDENT AND WITH *)
| /reversed_separated_nonempty_llist(AND,with_constraint): reversed_separated_nonempty_llist(AND,with_constraint) AND . with_constraint
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT COLONEQUAL UIDENT AND WITH" }

(* interface: INCLUDE LPAREN QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: LPAREN module_type . RPAREN
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "interface: INCLUDE LPAREN QUOTED_STRING_EXPR WHILE" }

(* implementation: INCLUDE QUOTED_STRING_EXPR LPAREN WITH *)
| /module_expr: module_expr LPAREN . RPAREN
  /paren_module_expr: LPAREN . module_expr COLON module_type RPAREN
  /paren_module_expr: LPAREN . module_expr RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr COLON module_type RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr COLON module_type COLONGREATER module_type RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr COLONGREATER module_type RPAREN
  { "implementation: INCLUDE QUOTED_STRING_EXPR LPAREN WITH" }

(* implementation: INCLUDE LPAREN QUOTED_STRING_EXPR WITH *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /paren_module_expr: LPAREN module_expr . COLON module_type RPAREN
     /paren_module_expr: LPAREN module_expr . RPAREN]
  { "implementation: INCLUDE LPAREN QUOTED_STRING_EXPR WITH" }

(* implementation: LAZY PERCENT AND WHILE *)
| [_ /expr: LAZY ext . list(attribute) simple_expr]
  { "implementation: LAZY PERCENT AND WHILE" }

(* implementation: UIDENT DOT WITH *)
| /constr_longident: mod_longident DOT . LPAREN COLONCOLON RPAREN
  /mk_longident(mod_longident,UIDENT): mod_longident DOT . UIDENT
  /mk_longident(mod_longident,val_ident): mod_longident DOT . val_ident
  /simple_expr: mod_longident DOT . LPAREN seq_expr RPAREN
  /simple_expr: mod_longident DOT . LBRACELESS separated_or_terminated_nonempty_list(SEMI,object_expr_field) GREATERRBRACE
  /simple_expr: mod_longident DOT . LPAREN RPAREN
  /simple_expr: mod_longident DOT . LBRACE record_expr_content RBRACE
  /simple_expr: mod_longident DOT . LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,expr) BARRBRACKET
  /simple_expr: mod_longident DOT . LBRACKETBAR BARRBRACKET
  /simple_expr: mod_longident DOT . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  /simple_expr: mod_longident DOT . LBRACKET RBRACKET
  /simple_expr: mod_longident DOT . LPAREN MODULE ext list(attribute) module_expr COLON module_type RPAREN
  { "implementation: UIDENT DOT WITH" }

(* implementation: LETOP LIDENT COLON WITH *)
| /letop_binding_body: simple_pattern COLON . core_type EQUAL seq_expr
  { "implementation: LETOP LIDENT COLON WITH" }

(* implementation: IF PERCENT AND VIRTUAL *)
| [_ /expr: IF ext . list(attribute) seq_expr THEN expr ELSE expr
     /expr: IF ext . list(attribute) seq_expr THEN expr]
  { "implementation: IF PERCENT AND VIRTUAL" }

(* implementation: FUNCTION PERCENT AND WHILE *)
| [_ /expr: FUNCTION ext . list(attribute) reversed_preceded_or_separated_nonempty_llist(BAR,match_case)]
  { "implementation: FUNCTION PERCENT AND WHILE" }

(* implementation: FUNCTION FALSE WHEN WITH *)
| /match_case: pattern WHEN . seq_expr MINUSGREATER seq_expr
  { "implementation: FUNCTION FALSE WHEN WITH" }

(* implementation: FUN PERCENT AND WHILE *)
| [_ /expr: FUN ext . list(attribute) labeled_simple_pattern fun_def
     /expr: FUN ext . list(attribute) LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN fun_def]
  { "implementation: FUN PERCENT AND WHILE" }

(* implementation: FUN OPTLABEL LPAREN WITH *)
| /labeled_simple_pattern: OPTLABEL LPAREN . let_pattern option(preceded(EQUAL,seq_expr)) RPAREN
  { "implementation: FUN OPTLABEL LPAREN WITH" }

(* implementation: FUN OPTLABEL LPAREN FALSE COLON WITH *)
| /let_pattern: pattern COLON . core_type
  { "implementation: FUN OPTLABEL LPAREN FALSE COLON WITH" }

(* implementation: FOR PERCENT AND WHILE *)
| [_ /expr: FOR ext . list(attribute) pattern EQUAL seq_expr direction_flag seq_expr DO seq_expr DONE]
  { "implementation: FOR PERCENT AND WHILE" }

(* implementation: UIDENT HASHOP WITH *)
| /simple_expr: simple_expr HASHOP . simple_expr
  { "implementation: UIDENT HASHOP WITH" }

(* implementation: UIDENT CHAR DOTOP WITH *)
| /simple_expr: simple_expr DOTOP . LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  /simple_expr: simple_expr DOTOP . LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  /simple_expr: simple_expr DOTOP . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: UIDENT CHAR DOTOP WITH" }

(* implementation: UIDENT OPTLABEL CHAR WHILE *)
| [_ /labeled_simple_expr: OPTLABEL simple_expr .
     /simple_expr: simple_expr . DOT LPAREN seq_expr RPAREN
     /simple_expr: simple_expr . DOT LBRACE seq_expr RBRACE
     /simple_expr: simple_expr . DOT LBRACKET seq_expr RBRACKET
     /simple_expr: simple_expr . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT label_longident
     /simple_expr: simple_expr . HASH LIDENT
     /simple_expr: simple_expr . HASHOP simple_expr]
  { "implementation: UIDENT OPTLABEL CHAR WHILE" }

(* implementation: UIDENT HASH WITH *)
| /simple_expr: simple_expr HASH . LIDENT
  { "implementation: UIDENT HASH WITH" }

(* implementation: UIDENT CHAR DOT WITH *)
| /simple_expr: simple_expr DOT . LPAREN seq_expr RPAREN
  /simple_expr: simple_expr DOT . LBRACE seq_expr RBRACE
  /simple_expr: simple_expr DOT . LBRACKET seq_expr RBRACKET
  /simple_expr: simple_expr DOT . mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  /simple_expr: simple_expr DOT . mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  /simple_expr: simple_expr DOT . mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  /simple_expr: simple_expr DOT . label_longident
  { "implementation: UIDENT CHAR DOT WITH" }

(* implementation: UIDENT COMMA UIDENT COMMA WITH *)
| /reversed_separated_nontrivial_llist(COMMA,expr): reversed_separated_nontrivial_llist(COMMA,expr) COMMA . expr
  { "implementation: UIDENT COMMA UIDENT COMMA WITH" }

(* implementation: LET LIDENT IN WITH *)
| /expr: let_bindings(ext) IN . seq_expr
  { "implementation: LET LIDENT IN WITH" }

(* implementation: UIDENT STAR WITH *)
| /expr: expr STAR . expr
  { "implementation: UIDENT STAR WITH" }

(* implementation: UIDENT INFIXOP4 WITH *)
| /expr: expr INFIXOP4 . expr
  { "implementation: UIDENT INFIXOP4 WITH" }

(* implementation: UIDENT PLUSEQ WITH *)
| /expr: expr PLUSEQ . expr
  { "implementation: UIDENT PLUSEQ WITH" }

(* implementation: UIDENT PERCENT WITH *)
| /expr: expr PERCENT . expr
  { "implementation: UIDENT PERCENT WITH" }

(* implementation: UIDENT INFIXOP3 WITH *)
| /expr: expr INFIXOP3 . expr
  { "implementation: UIDENT INFIXOP3 WITH" }

(* implementation: UIDENT PLUSDOT WITH *)
| /expr: expr PLUSDOT . expr
  { "implementation: UIDENT PLUSDOT WITH" }

(* implementation: UIDENT PLUS WITH *)
| /expr: expr PLUS . expr
  { "implementation: UIDENT PLUS WITH" }

(* implementation: UIDENT OR WITH *)
| /expr: expr OR . expr
  { "implementation: UIDENT OR WITH" }

(* implementation: UIDENT MINUSDOT WITH *)
| /expr: expr MINUSDOT . expr
  { "implementation: UIDENT MINUSDOT WITH" }

(* implementation: UIDENT MINUS WITH *)
| /expr: expr MINUS . expr
  { "implementation: UIDENT MINUS WITH" }

(* implementation: UIDENT LESS WITH *)
| /expr: expr LESS . expr
  { "implementation: UIDENT LESS WITH" }

(* implementation: UIDENT INFIXOP2 WITH *)
| /expr: expr INFIXOP2 . expr
  { "implementation: UIDENT INFIXOP2 WITH" }

(* implementation: UIDENT INFIXOP1 WITH *)
| /expr: expr INFIXOP1 . expr
  { "implementation: UIDENT INFIXOP1 WITH" }

(* implementation: UIDENT COLONCOLON WITH *)
| /expr: expr COLONCOLON . expr
  { "implementation: UIDENT COLONCOLON WITH" }

(* implementation: UIDENT INFIXOP0 WITH *)
| /expr: expr INFIXOP0 . expr
  { "implementation: UIDENT INFIXOP0 WITH" }

(* implementation: UIDENT GREATER WITH *)
| /expr: expr GREATER . expr
  { "implementation: UIDENT GREATER WITH" }

(* implementation: UIDENT EQUAL WITH *)
| /expr: expr EQUAL . expr
  { "implementation: UIDENT EQUAL WITH" }

(* implementation: UIDENT BARBAR WITH *)
| /expr: expr BARBAR . expr
  { "implementation: UIDENT BARBAR WITH" }

(* implementation: UIDENT AMPERSAND WITH *)
| /expr: expr AMPERSAND . expr
  { "implementation: UIDENT AMPERSAND WITH" }

(* implementation: UIDENT AMPERAMPER WITH *)
| /expr: expr AMPERAMPER . expr
  { "implementation: UIDENT AMPERAMPER WITH" }

(* implementation: UIDENT COMMA WITH *)
| /reversed_separated_nontrivial_llist(COMMA,expr): expr COMMA . expr
  { "implementation: UIDENT COMMA WITH" }

(* implementation: UIDENT COLONEQUAL WITH *)
| /expr: expr COLONEQUAL . expr
  { "implementation: UIDENT COLONEQUAL WITH" }

(* implementation: LET LIDENT AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /and_let_binding: AND list(attribute) . let_binding_body list(post_item_attribute)]
  { "implementation: LET LIDENT AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: LETOP LIDENT LPAREN TYPE WITH *)
| /strict_binding: LPAREN TYPE . nonempty_list(mkrhs(LIDENT)) RPAREN fun_binding
  { "implementation: LETOP LIDENT LPAREN TYPE WITH" }

(* implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /type_constraint: COLON core_type .
     /type_constraint: COLON core_type . COLONGREATER core_type]
  { "implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: LETOP LIDENT FALSE COLON QUOTED_STRING_EXPR EQUAL WITH *)
| /fun_binding: type_constraint EQUAL . seq_expr
  { "implementation: LETOP LIDENT FALSE COLON QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: LET LIDENT COLON WITH *)
| /let_binding_body_no_punning: val_ident COLON . reversed_nonempty_llist(typevar) DOT core_type EQUAL seq_expr
  /let_binding_body_no_punning: val_ident COLON . TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  /type_constraint: COLON . core_type
  /type_constraint: COLON . core_type COLONGREATER core_type
  { "implementation: LET LIDENT COLON WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTE LIDENT QUOTE WITH *)
| /reversed_nonempty_llist(typevar): reversed_nonempty_llist(typevar) QUOTE . ident
  { "parse_core_type: LESS LIDENT COLON QUOTE LIDENT QUOTE WITH" }

(* implementation: LET LIDENT COLON QUOTED_STRING_EXPR RBRACE *)
| [_ /let_binding_body_no_punning: val_ident type_constraint . EQUAL seq_expr]
  { "implementation: LET LIDENT COLON QUOTED_STRING_EXPR RBRACE" }

(* implementation: LET FALSE COLON WITH *)
| /let_binding_body_no_punning: simple_pattern_not_ident COLON . core_type EQUAL seq_expr
  { "implementation: LET FALSE COLON WITH" }

(* implementation: LET FALSE EQUAL WITH *)
| /let_binding_body_no_punning: pattern_no_exn EQUAL . seq_expr
  { "implementation: LET FALSE EQUAL WITH" }

(* implementation: LETOP LIDENT COMMA WITH *)
| /pattern_comma_list(pattern_no_exn): pattern_no_exn COMMA . pattern
  { "implementation: LETOP LIDENT COMMA WITH" }

(* implementation: LETOP LIDENT COLONCOLON WITH *)
| /pattern_no_exn: pattern_no_exn COLONCOLON . pattern
  { "implementation: LETOP LIDENT COLONCOLON WITH" }

(* implementation: LETOP LIDENT BAR WITH *)
| /pattern_no_exn: pattern_no_exn BAR . pattern
  { "implementation: LETOP LIDENT BAR WITH" }

(* implementation: LETOP LIDENT AS WITH *)
| /pattern_no_exn: pattern_no_exn AS . val_ident
  { "implementation: LETOP LIDENT AS WITH" }

(* implementation: LETOP LIDENT COMMA FALSE COMMA WITH *)
| /pattern_comma_list(pattern_no_exn): pattern_comma_list(pattern_no_exn) COMMA . pattern
  { "implementation: LETOP LIDENT COMMA FALSE COMMA WITH" }

(* implementation: LBRACKET UIDENT SEMI WITH *)
| /separated_or_terminated_nonempty_list(SEMI,expr): expr SEMI .
  /separated_or_terminated_nonempty_list(SEMI,expr): expr SEMI . separated_or_terminated_nonempty_list(SEMI,expr)
  { "implementation: LBRACKET UIDENT SEMI WITH" }

(* implementation: UIDENT LABEL CHAR WHILE *)
| [_ /labeled_simple_expr: LABEL simple_expr .
     /simple_expr: simple_expr . DOT LPAREN seq_expr RPAREN
     /simple_expr: simple_expr . DOT LBRACE seq_expr RBRACE
     /simple_expr: simple_expr . DOT LBRACKET seq_expr RBRACKET
     /simple_expr: simple_expr . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT label_longident
     /simple_expr: simple_expr . HASH LIDENT
     /simple_expr: simple_expr . HASHOP simple_expr]
  { "implementation: UIDENT LABEL CHAR WHILE" }

(* implementation: UIDENT DOTOP WITH *)
| /expr: simple_expr DOTOP . LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS expr
  /expr: simple_expr DOTOP . LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS expr
  /expr: simple_expr DOTOP . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS expr
  /simple_expr: simple_expr DOTOP . LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  /simple_expr: simple_expr DOTOP . LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  /simple_expr: simple_expr DOTOP . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: UIDENT DOTOP WITH" }

(* implementation: FALSE DOT WITH *)
| /expr: simple_expr DOT . label_longident LESSMINUS expr
  /expr: simple_expr DOT . LPAREN seq_expr RPAREN LESSMINUS expr
  /expr: simple_expr DOT . LBRACE seq_expr RBRACE LESSMINUS expr
  /expr: simple_expr DOT . LBRACKET seq_expr RBRACKET LESSMINUS expr
  /expr: simple_expr DOT . mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN LESSMINUS expr
  /expr: simple_expr DOT . mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE LESSMINUS expr
  /expr: simple_expr DOT . mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET LESSMINUS expr
  /simple_expr: simple_expr DOT . LPAREN seq_expr RPAREN
  /simple_expr: simple_expr DOT . LBRACE seq_expr RBRACE
  /simple_expr: simple_expr DOT . LBRACKET seq_expr RBRACKET
  /simple_expr: simple_expr DOT . mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
  /simple_expr: simple_expr DOT . mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
  /simple_expr: simple_expr DOT . mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  /simple_expr: simple_expr DOT . label_longident
  { "implementation: FALSE DOT WITH" }

(* implementation: FUN FALSE LPAREN TYPE WITH *)
| /fun_def: LPAREN TYPE . nonempty_list(mkrhs(LIDENT)) RPAREN fun_def
  { "implementation: FUN FALSE LPAREN TYPE WITH" }

(* implementation: FUN FALSE COLON QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /fun_def: COLON atomic_type . MINUSGREATER seq_expr]
  { "implementation: FUN FALSE COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: FUNCTION FALSE MINUSGREATER WITH *)
| /match_case: pattern MINUSGREATER . seq_expr
  /match_case: pattern MINUSGREATER . DOT
  { "implementation: FUNCTION FALSE MINUSGREATER WITH" }

(* implementation: FUNCTION FALSE MINUSGREATER UIDENT BAR WITH *)
| /reversed_preceded_or_separated_nonempty_llist(BAR,match_case): reversed_preceded_or_separated_nonempty_llist(BAR,match_case) BAR . match_case
  { "implementation: FUNCTION FALSE MINUSGREATER UIDENT BAR WITH" }

(* implementation: LETOP FALSE EQUAL WITH *)
| /letop_binding_body: pattern_no_exn EQUAL . seq_expr
  { "implementation: LETOP FALSE EQUAL WITH" }

(* implementation: LETOP LIDENT EQUAL UIDENT VAL *)
| [_ /expr: LETOP letop_bindings . IN seq_expr
     /letop_bindings: letop_bindings . ANDOP letop_binding_body]
  { "implementation: LETOP LIDENT EQUAL UIDENT VAL" }

(* implementation: LETOP LIDENT ANDOP WITH *)
| /letop_bindings: letop_bindings ANDOP . letop_binding_body
  { "implementation: LETOP LIDENT ANDOP WITH" }

(* implementation: LBRACE CHAR WITH WITH *)
| /record_expr_content: simple_expr WITH . separated_or_terminated_nonempty_list(SEMI,record_expr_field)
  { "implementation: LBRACE CHAR WITH WITH" }

(* implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR RPAREN *)
| [_ /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) . option(preceded(EQUAL,expr))
     /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) . option(preceded(EQUAL,expr)) SEMI
     /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident option(type_constraint) . option(preceded(EQUAL,expr)) SEMI separated_or_terminated_nonempty_list(SEMI,record_expr_field)]
  { "implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR RPAREN" }

(* implementation: LBRACE UIDENT DOT WITH *)
| /constr_longident: mod_longident DOT . LPAREN COLONCOLON RPAREN
  /mk_longident(mod_longident,LIDENT): mod_longident DOT . LIDENT
  /mk_longident(mod_longident,UIDENT): mod_longident DOT . UIDENT
  /mk_longident(mod_longident,val_ident): mod_longident DOT . val_ident
  /simple_expr: mod_longident DOT . LPAREN seq_expr RPAREN
  /simple_expr: mod_longident DOT . LBRACELESS separated_or_terminated_nonempty_list(SEMI,object_expr_field) GREATERRBRACE
  /simple_expr: mod_longident DOT . LPAREN RPAREN
  /simple_expr: mod_longident DOT . LBRACE record_expr_content RBRACE
  /simple_expr: mod_longident DOT . LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,expr) BARRBRACKET
  /simple_expr: mod_longident DOT . LBRACKETBAR BARRBRACKET
  /simple_expr: mod_longident DOT . LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  /simple_expr: mod_longident DOT . LBRACKET RBRACKET
  /simple_expr: mod_longident DOT . LPAREN MODULE ext list(attribute) module_expr COLON module_type RPAREN
  { "implementation: LBRACE UIDENT DOT WITH" }

(* implementation: LBRACELESS LIDENT EQUAL UIDENT VAL *)
| [_ /expr: expr . INFIXOP0 expr
     /expr: expr . INFIXOP1 expr
     /expr: expr . INFIXOP2 expr
     /expr: expr . INFIXOP3 expr
     /expr: expr . INFIXOP4 expr
     /expr: expr . PLUS expr
     /expr: expr . PLUSDOT expr
     /expr: expr . PLUSEQ expr
     /expr: expr . MINUS expr
     /expr: expr . MINUSDOT expr
     /expr: expr . STAR expr
     /expr: expr . PERCENT expr
     /expr: expr . EQUAL expr
     /expr: expr . LESS expr
     /expr: expr . GREATER expr
     /expr: expr . OR expr
     /expr: expr . BARBAR expr
     /expr: expr . AMPERSAND expr
     /expr: expr . AMPERAMPER expr
     /expr: expr . COLONEQUAL expr
     /expr: expr . COLONCOLON expr
     /expr: expr . attribute
     /option(preceded(EQUAL,expr)): EQUAL expr .
     /reversed_separated_nontrivial_llist(COMMA,expr): expr . COMMA expr]
  { "implementation: LBRACELESS LIDENT EQUAL UIDENT VAL" }

(* implementation: LBRACELESS LIDENT EQUAL UIDENT RBRACE *)
| [_ /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT option(preceded(EQUAL,expr)) .
     /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT option(preceded(EQUAL,expr)) . SEMI
     /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT option(preceded(EQUAL,expr)) . SEMI separated_or_terminated_nonempty_list(SEMI,object_expr_field)]
  { "implementation: LBRACELESS LIDENT EQUAL UIDENT RBRACE" }

(* implementation: LBRACKET UIDENT RPAREN *)
| [_ /simple_expr: LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) . RBRACKET]
  { "implementation: LBRACKET UIDENT RPAREN" }

(* implementation: LET MODULE WITH *)
| /expr: LET MODULE . ext list(attribute) module_name module_binding_body IN seq_expr
  { "implementation: LET MODULE WITH" }

(* implementation: MODULE UIDENT EQUAL QUOTED_STRING_EXPR WITH *)
| [_ /module_binding_body: EQUAL module_expr .
     /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN]
  { "implementation: MODULE UIDENT EQUAL QUOTED_STRING_EXPR WITH" }

(* implementation: MODULE UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_binding_body: COLON module_type . EQUAL module_expr
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "implementation: MODULE UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: LET EXCEPTION WITH *)
| /expr: LET EXCEPTION . ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) IN seq_expr
  { "implementation: LET EXCEPTION WITH" }

(* implementation: EXCEPTION LPAREN COLONCOLON WITH *)
| /constr_ident: LPAREN COLONCOLON . RPAREN
  { "implementation: EXCEPTION LPAREN COLONCOLON WITH" }

(* implementation: EXCEPTION FALSE COLON LBRACE LIDENT WITH *)
| /label_declaration: mutable_flag LIDENT . COLON possibly_poly(core_type_no_attr) list(attribute)
  /label_declaration_semi: mutable_flag LIDENT . COLON possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute)
  { "implementation: EXCEPTION FALSE COLON LBRACE LIDENT WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTE LIDENT DOT WITH *)
| /possibly_poly(core_type_no_attr): reversed_nonempty_llist(typevar) DOT . alias_type
  { "parse_core_type: LESS LIDENT COLON QUOTE LIDENT DOT WITH" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR STAR WITH *)
| /constructor_arguments: reversed_separated_nonempty_llist(STAR,atomic_type) STAR . atomic_type
  /reversed_separated_nonempty_llist(STAR,atomic_type): reversed_separated_nonempty_llist(STAR,atomic_type) STAR . atomic_type
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR STAR WITH" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR VAL *)
| [_ /generalized_constructor_arguments: COLON constructor_arguments . MINUSGREATER atomic_type]
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR VAL" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /constructor_arguments: atomic_type .
     /generalized_constructor_arguments: COLON atomic_type .
     /reversed_separated_nonempty_llist(STAR,atomic_type): atomic_type .]
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR WHILE" }

(* implementation: LET PERCENT AND WHILE *)
| [_ /let_bindings(ext): LET ext . list(attribute) rec_flag let_binding_body list(post_item_attribute)]
  { "implementation: LET PERCENT AND WHILE" }

(* implementation: OPEN PERCENT AND WHILE *)
| [_ /open_declaration: OPEN ext . list(attribute) module_expr list(post_item_attribute)]
  { "implementation: OPEN PERCENT AND WHILE" }

(* implementation: MODULE TYPE WITH *)
| /module_type_declaration: MODULE TYPE . ext list(attribute) ident option(preceded(EQUAL,module_type)) list(post_item_attribute)
  { "implementation: MODULE TYPE WITH" }

(* implementation: MODULE PERCENT AND WHILE *)
| [_ /structure_item: MODULE ext . list(attribute) module_name module_binding_body list(post_item_attribute)
     /structure_item: MODULE ext . list(attribute) REC module_name module_binding_body list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE PERCENT AND WHILE" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(and_module_binding): AND list(attribute) . module_name module_binding_body list(post_item_attribute) list(and_module_binding)]
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: LBRACKETPERCENTPERCENT AND VIRTUAL *)
| [_ /item_extension: LBRACKETPERCENTPERCENT attr_id . payload RBRACKET]
  { "implementation: LBRACKETPERCENTPERCENT AND VIRTUAL" }

(* implementation: LBRACKETATATAT AND QUESTION QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /payload: QUESTION pattern .
     /payload: QUESTION pattern . WHEN seq_expr]
  { "implementation: LBRACKETATATAT AND QUESTION QUOTED_STRING_EXPR WHILE" }

(* implementation: LBRACKETATATAT AND VIRTUAL *)
| [_ /floating_attribute: LBRACKETATATAT attr_id . payload RBRACKET]
  { "implementation: LBRACKETATATAT AND VIRTUAL" }

(* implementation: INCLUDE PERCENT AND WHILE *)
| [_ /structure_item: INCLUDE ext . list(attribute) module_expr list(post_item_attribute)]
  { "implementation: INCLUDE PERCENT AND WHILE" }

(* implementation: EXTERNAL PERCENT AND WHILE *)
| [_ /primitive_declaration: EXTERNAL ext . list(attribute) val_ident COLON core_type EQUAL nonempty_list(raw_string) list(post_item_attribute)]
  { "implementation: EXTERNAL PERCENT AND WHILE" }

(* implementation: EXCEPTION PERCENT AND WHILE *)
| [_ /sig_exception_declaration: EXCEPTION ext . list(attribute) constr_ident generalized_constructor_arguments list(attribute) list(post_item_attribute)
     /str_exception_declaration: EXCEPTION ext . list(attribute) constr_ident EQUAL constr_longident list(attribute) list(post_item_attribute)]
  { "implementation: EXCEPTION PERCENT AND WHILE" }

(* parse_constr_longident: UIDENT DOT WITH *)
| /constr_longident: mod_longident DOT . LPAREN COLONCOLON RPAREN
  /mk_longident(mod_longident,UIDENT): mod_longident DOT . UIDENT
  { "parse_constr_longident: UIDENT DOT WITH" }

(* interface: OPEN BANG WITH *)
| /open_description: OPEN BANG . ext list(attribute) mod_ext_longident list(post_item_attribute)
  { "interface: OPEN BANG WITH" }

(* interface: OPEN PERCENT AND WHILE *)
| [_ /open_description: OPEN ext . list(attribute) mod_ext_longident list(post_item_attribute)]
  { "interface: OPEN PERCENT AND WHILE" }

(* interface: MODULE TYPE WITH *)
| /module_type_declaration: MODULE TYPE . ext list(attribute) ident option(preceded(EQUAL,module_type)) list(post_item_attribute)
  /module_type_subst: MODULE TYPE . ext list(attribute) ident COLONEQUAL module_type list(post_item_attribute)
  { "interface: MODULE TYPE WITH" }

(* interface: MODULE PERCENT AND WHILE *)
| [_ /module_subst: MODULE ext . list(attribute) UIDENT COLONEQUAL mod_ext_longident list(post_item_attribute)
     /signature_item: MODULE ext . list(attribute) module_name module_declaration_body list(post_item_attribute)
     /signature_item: MODULE ext . list(attribute) module_name EQUAL mod_longident list(post_item_attribute)
     /signature_item: MODULE ext . list(attribute) REC module_name COLON module_type list(post_item_attribute) list(and_module_declaration)]
  { "interface: MODULE PERCENT AND WHILE" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(and_module_declaration): AND list(attribute) . module_name COLON module_type list(post_item_attribute) list(and_module_declaration)]
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND LBRACKETAT AND RBRACKET WHILE" }

(* interface: MODULE UIDENT COLON QUOTED_STRING_EXPR WHILE *)
| [_ /module_declaration_body: COLON module_type .
     /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)]
  { "interface: MODULE UIDENT COLON QUOTED_STRING_EXPR WHILE" }

(* interface: INCLUDE PERCENT AND WHILE *)
| [_ /signature_item: INCLUDE ext . list(attribute) module_type list(post_item_attribute)]
  { "interface: INCLUDE PERCENT AND WHILE" }

(* interface: EXCEPTION PERCENT AND WHILE *)
| [_ /sig_exception_declaration: EXCEPTION ext . list(attribute) constr_ident generalized_constructor_arguments list(attribute) list(post_item_attribute)]
  { "interface: EXCEPTION PERCENT AND WHILE" }

(* implementation: TYPE LIDENT AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(generic_and_type_declaration(type_kind)): AND list(attribute) . type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_kind))]
  { "implementation: TYPE LIDENT AND LBRACKETAT AND RBRACKET WHILE" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND LBRACKETAT AND RBRACKET WHILE *)
| [_ /list(generic_and_type_declaration(type_subst_kind)): AND list(attribute) . type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_subst_kind))]
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND LBRACKETAT AND RBRACKET WHILE" }

(* implementation: TYPE LIDENT EQUAL BAR FALSE WITH *)
| [_ /generic_constructor_declaration(BAR): BAR constr_ident . generalized_constructor_arguments list(attribute)]
  { "implementation: TYPE LIDENT EQUAL BAR FALSE WITH" }

(* implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL WITH *)
| /nonempty_type_kind: core_type EQUAL . constructor_declarations
  /nonempty_type_kind: core_type EQUAL . PRIVATE constructor_declarations
  /nonempty_type_kind: core_type EQUAL . DOTDOT
  /nonempty_type_kind: core_type EQUAL . PRIVATE DOTDOT
  /nonempty_type_kind: core_type EQUAL . LBRACE label_declarations RBRACE
  /nonempty_type_kind: core_type EQUAL . PRIVATE LBRACE label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR EQUAL WITH" }

(* implementation: TYPE LIDENT EQUAL FALSE COLON QUOTED_STRING_EXPR IN *)
| [_ /generic_constructor_declaration(epsilon): constr_ident generalized_constructor_arguments . list(attribute)]
  { "implementation: TYPE LIDENT EQUAL FALSE COLON QUOTED_STRING_EXPR IN" }

(* implementation: UIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /structure: seq_expr list(post_item_attribute) . list(structure_element)]
  { "implementation: UIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: SEMISEMI UIDENT TO *)
| [_ /list(structure_element): SEMISEMI seq_expr . list(post_item_attribute) list(structure_element)]
  { "implementation: SEMISEMI UIDENT TO" }

(* implementation: OBJECT LPAREN QUOTED_STRING_EXPR WHILE *)
| [_ /class_self_pattern: LPAREN pattern . RPAREN
     /class_self_pattern: LPAREN pattern . COLON core_type RPAREN
     /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern]
  { "implementation: OBJECT LPAREN QUOTED_STRING_EXPR WHILE" }

(* implementation: LBRACKETBAR UIDENT RPAREN *)
| [_ /simple_expr: LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,expr) . BARRBRACKET]
  { "implementation: LBRACKETBAR UIDENT RPAREN" }

(* implementation: LPAREN MODULE WITH *)
| /simple_expr: LPAREN MODULE . ext list(attribute) module_expr RPAREN
  /simple_expr: LPAREN MODULE . ext list(attribute) module_expr COLON module_type RPAREN
  { "implementation: LPAREN MODULE WITH" }

(* implementation: LPAREN UIDENT VAL *)
| [_ /simple_expr: LPAREN seq_expr . RPAREN
     /simple_expr: LPAREN seq_expr . type_constraint RPAREN]
  { "implementation: LPAREN UIDENT VAL" }

(* implementation: TYPE LIDENT PLUSEQ BAR FALSE WITH *)
| [_ /extension_constructor_rebind(BAR): BAR constr_ident . EQUAL constr_longident list(attribute)
     /generic_constructor_declaration(BAR): BAR constr_ident . generalized_constructor_arguments list(attribute)]
  { "implementation: TYPE LIDENT PLUSEQ BAR FALSE WITH" }

(* implementation: TYPE LIDENT PLUSEQ FALSE EQUAL WITH *)
| /extension_constructor_rebind(epsilon): constr_ident EQUAL . constr_longident list(attribute)
  { "implementation: TYPE LIDENT PLUSEQ FALSE EQUAL WITH" }

(* parse_core_type: LESS QUOTED_STRING_EXPR SEMI WITH *)
| /meth_list: atomic_type SEMI . meth_list
  /meth_list: atomic_type SEMI .
  { "parse_core_type: LESS QUOTED_STRING_EXPR SEMI WITH" }

(* parse_core_type: LESS DOTDOT WITH *)
| [_ /atomic_type: LESS meth_list . GREATER]
  { "parse_core_type: LESS DOTDOT WITH" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR COMMA WITH *)
| /reversed_separated_nontrivial_llist(COMMA,core_type): reversed_separated_nontrivial_llist(COMMA,core_type) COMMA . core_type
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR COMMA WITH" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR WITH *)
| [_ /atomic_type: LPAREN core_type . RPAREN
     /core_type: core_type . attribute
     /reversed_separated_nontrivial_llist(COMMA,core_type): core_type . COMMA core_type]
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR WITH" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA WITH *)
| /reversed_separated_nontrivial_llist(COMMA,core_type): core_type COMMA . core_type
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA WITH" }

(* implementation: TYPE LIDENT EQUAL PRIVATE LBRACE WITH *)
| /nonempty_type_kind: PRIVATE LBRACE . label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL PRIVATE LBRACE WITH" }

(* implementation: QUOTED_STRING_ITEM HASH *)
| [_ /list(structure_element): structure_item . list(structure_element)]
  { "implementation: QUOTED_STRING_ITEM HASH" }

(* interface: TYPE WITH *)
| /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE . ext list(attribute) type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(no_nonrec_flag,type_subst_kind): TYPE . ext list(attribute) NONREC type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(nonrec_flag,type_kind): TYPE . ext list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(nonrec_flag,type_kind): TYPE . ext list(attribute) NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /signature_item: TYPE . ext list(attribute) type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
  /signature_item: TYPE . ext list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor_declaration) list(post_item_attribute)
  { "interface: TYPE WITH" }

(* toplevel_phrase: HASH WITH *)
| /toplevel_directive: HASH . ident
  /toplevel_directive: HASH . ident STRING
  /toplevel_directive: HASH . ident INT
  /toplevel_directive: HASH . ident val_longident
  /toplevel_directive: HASH . ident mod_longident
  /toplevel_directive: HASH . ident FALSE
  /toplevel_directive: HASH . ident TRUE
  { "toplevel_phrase: HASH WITH" }

(* parse_core_type: LPAREN WITH *)
| /atomic_type: LPAREN . core_type RPAREN
  /atomic_type: LPAREN . MODULE ext list(attribute) module_type RPAREN
  /atomic_type: LPAREN . reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN type_longident
  /atomic_type: LPAREN . reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN HASH clty_longident
  { "parse_core_type: LPAREN WITH" }

(* parse_any_longident: UIDENT LPAREN UIDENT RPAREN WITH *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mk_longident(mod_ext_longident,__anonymous_41): mod_ext_longident . DOT ident
     /mk_longident(mod_ext_longident,__anonymous_41): mod_ext_longident . DOT LPAREN COLONCOLON RPAREN
     /mk_longident(mod_ext_longident,__anonymous_41): mod_ext_longident . DOT val_extra_ident
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN]
  { "parse_any_longident: UIDENT LPAREN UIDENT RPAREN WITH" }

(* implementation: LPAREN DOTOP WITH *)
| /operator: DOTOP . LPAREN index_mod RPAREN
  /operator: DOTOP . LPAREN index_mod RPAREN LESSMINUS
  /operator: DOTOP . LBRACKET index_mod RBRACKET
  /operator: DOTOP . LBRACKET index_mod RBRACKET LESSMINUS
  /operator: DOTOP . LBRACE index_mod RBRACE
  /operator: DOTOP . LBRACE index_mod RBRACE LESSMINUS
  { "implementation: LPAREN DOTOP WITH" }

(* implementation: TYPE WITH *)
| /generic_type_declaration(nonrec_flag,type_kind): TYPE . ext list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /generic_type_declaration(nonrec_flag,type_kind): TYPE . ext list(attribute) NONREC type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute)
  /structure_item: TYPE . ext list(attribute) type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
  /structure_item: TYPE . ext list(attribute) NONREC type_parameters type_longident PLUSEQ private_flag reversed_bar_llist(extension_constructor) list(post_item_attribute)
  { "implementation: TYPE WITH" }

(* implementation: WHILE WITH *)
| /expr: WHILE . ext list(attribute) seq_expr DO seq_expr DONE
  { "implementation: WHILE WITH" }

(* implementation: ASSERT PERCENT UNDERSCORE *)
| /ext: PERCENT . attr_id
  { "implementation: ASSERT PERCENT UNDERSCORE" }

(* implementation: LBRACKETATATAT AND WITH *)
| [_ /attr_id: single_attr_id .
     /attr_id: single_attr_id . DOT attr_id]
  { "implementation: LBRACKETATATAT AND WITH" }

(* implementation: UIDENT LBRACKETAT UNDERSCORE *)
| /attribute: LBRACKETAT . attr_id payload RBRACKET
  { "implementation: UIDENT LBRACKETAT UNDERSCORE" }

(* implementation: VAL WITH *)
| /value_description: VAL . ext list(attribute) val_ident COLON core_type list(post_item_attribute)
  { "implementation: VAL WITH" }

(* parse_val_longident: LPAREN WITH *)
| /val_extra_ident: LPAREN . operator RPAREN
  { "parse_val_longident: LPAREN WITH" }

(* implementation: LPAREN DOTOP LBRACE SEMI WITH *)
| /index_mod: SEMI . DOTDOT
  { "implementation: LPAREN DOTOP LBRACE SEMI WITH" }

(* parse_core_type: QUOTE WITH *)
| /atomic_type: QUOTE . ident
  { "parse_core_type: QUOTE WITH" }

(* parse_core_type: QUESTION WITH *)
| /optlabel: QUESTION . LIDENT COLON
  { "parse_core_type: QUESTION WITH" }

(* parse_any_longident: UIDENT WHILE *)
| /ident: UIDENT .
  /mk_longident(mod_ext_longident,UIDENT): UIDENT .
  { "parse_any_longident: UIDENT WHILE" }

(* interface: INCLUDE SIG WITH *)
| /module_type: SIG . list(attribute) signature END
  { "interface: INCLUDE SIG WITH" }

(* implementation: TYPE PLUS WITH *)
| /type_variance: PLUS .
  /type_variance: PLUS . BANG
  { "implementation: TYPE PLUS WITH" }

(* implementation: TYPE MINUS WITH *)
| /type_variance: MINUS .
  /type_variance: MINUS . BANG
  { "implementation: TYPE MINUS WITH" }

(* implementation: TYPE LPAREN WITH *)
| /type_parameters: LPAREN . reversed_separated_nonempty_llist(COMMA,type_parameter) RPAREN
  { "implementation: TYPE LPAREN WITH" }

(* implementation: TYPE BANG WITH *)
| /type_variance: BANG .
  /type_variance: BANG . PLUS
  /type_variance: BANG . MINUS
  { "implementation: TYPE BANG WITH" }

(* implementation: TYPE INFIXOP2 WITH *)
| [_ /type_parameter: type_variance . type_variable]
  { "implementation: TYPE INFIXOP2 WITH" }

(* implementation: TYPE QUOTE WITH *)
| /type_variable: QUOTE . ident
  { "implementation: TYPE QUOTE WITH" }

(* implementation: TYPE LIDENT EQUAL WITH *)
| /type_kind: EQUAL . nonempty_type_kind
  { "implementation: TYPE LIDENT EQUAL WITH" }

(* implementation: TYPE LIDENT EQUAL UIDENT WITH *)
| /constr_ident: UIDENT .
  /mk_longident(mod_ext_longident,UIDENT): UIDENT .
  { "implementation: TYPE LIDENT EQUAL UIDENT WITH" }

(* implementation: TYPE LIDENT EQUAL PRIVATE WITH *)
| /nonempty_type_kind: PRIVATE . core_type
  /nonempty_type_kind: PRIVATE . constructor_declarations
  /nonempty_type_kind: PRIVATE . DOTDOT
  /nonempty_type_kind: PRIVATE . LBRACE label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL PRIVATE WITH" }

(* implementation: TYPE LIDENT EQUAL LPAREN WITH *)
| /atomic_type: LPAREN . core_type RPAREN
  /atomic_type: LPAREN . MODULE ext list(attribute) module_type RPAREN
  /atomic_type: LPAREN . reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN type_longident
  /atomic_type: LPAREN . reversed_separated_nontrivial_llist(COMMA,core_type) RPAREN HASH clty_longident
  /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_ident: LPAREN . COLONCOLON RPAREN
  { "implementation: TYPE LIDENT EQUAL LPAREN WITH" }

(* parse_core_type: LIDENT WHILE *)
| /function_type: LIDENT . COLON tuple_type MINUSGREATER function_type
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "parse_core_type: LIDENT WHILE" }

(* parse_core_type: LESS WITH *)
| /atomic_type: LESS . meth_list GREATER
  /atomic_type: LESS . GREATER
  { "parse_core_type: LESS WITH" }

(* parse_core_type: LESS LIDENT WITH *)
| /meth_list: LIDENT . COLON possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute) meth_list
  /meth_list: LIDENT . COLON possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute)
  /meth_list: LIDENT . COLON possibly_poly(core_type_no_attr) list(attribute)
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "parse_core_type: LESS LIDENT WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTE WITH *)
| /atomic_type: QUOTE . ident
  /reversed_nonempty_llist(typevar): QUOTE . ident
  { "parse_core_type: LESS LIDENT COLON QUOTE WITH" }

(* implementation: LBRACKETPERCENT UNDERSCORE *)
| /extension: LBRACKETPERCENT . attr_id payload RBRACKET
  { "implementation: LBRACKETPERCENT UNDERSCORE" }

(* implementation: QUOTED_STRING_ITEM LBRACKETATAT UNDERSCORE *)
| /post_item_attribute: LBRACKETATAT . attr_id payload RBRACKET
  { "implementation: QUOTED_STRING_ITEM LBRACKETATAT UNDERSCORE" }

(* implementation: TRY WITH *)
| /expr: TRY . ext list(attribute) seq_expr WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)
  { "implementation: TRY WITH" }

(* implementation: PREFIXOP WITH *)
| /simple_expr: PREFIXOP . simple_expr
  { "implementation: PREFIXOP WITH" }

(* implementation: NEW WITH *)
| /simple_expr: NEW . ext list(attribute) class_longident
  { "implementation: NEW WITH" }

(* parse_pattern: LBRACE UIDENT WITH *)
| [_ /mk_longident(mod_longident,LIDENT): mod_longident . DOT LIDENT
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT]
  { "parse_pattern: LBRACE UIDENT WITH" }

(* implementation: CLASS LIDENT COLON LIDENT WITH *)
| /class_type: LIDENT . COLON tuple_type MINUSGREATER class_type
  /mk_longident(mod_ext_longident,LIDENT): LIDENT .
  { "implementation: CLASS LIDENT COLON LIDENT WITH" }

(* implementation: CLASS LIDENT COLON LBRACKET WITH *)
| /atomic_type: LBRACKET . tag_field RBRACKET
  /atomic_type: LBRACKET . BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /atomic_type: LBRACKET . row_field BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /class_signature: LBRACKET . reversed_separated_nonempty_llist(COMMA,core_type) RBRACKET clty_longident
  { "implementation: CLASS LIDENT COLON LBRACKET WITH" }

(* implementation: CLASS LIDENT COLON LBRACKET QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /reversed_separated_nonempty_llist(COMMA,core_type): core_type .
     /row_field: core_type .]
  { "implementation: CLASS LIDENT COLON LBRACKET QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON UNDERSCORE WITH *)
| [_ /class_type: tuple_type . MINUSGREATER class_type]
  { "implementation: CLASS LIDENT COLON UNDERSCORE WITH" }

(* implementation: CLASS LIDENT COLON OPTLABEL WITH *)
| [_ /class_type: optlabel . tuple_type MINUSGREATER class_type]
  { "implementation: CLASS LIDENT COLON OPTLABEL WITH" }

(* implementation: CLASS LIDENT COLON UIDENT DOT LIDENT WITH *)
| [_ /clty_longident: mk_longident(mod_ext_longident,LIDENT) .
     /type_longident: mk_longident(mod_ext_longident,LIDENT) .]
  { "implementation: CLASS LIDENT COLON UIDENT DOT LIDENT WITH" }

(* implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /atomic_type: extension .
     /class_signature: extension .]
  { "implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OBJECT END METHOD *)
| [_ /class_signature: class_signature . attribute
     /class_type: class_signature .]
  { "implementation: CLASS LIDENT COLON OBJECT END METHOD" }

(* interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND WITH *)
| /list(and_class_description): AND . list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)
  { "interface: CLASS LIDENT COLON QUOTED_STRING_EXPR AND WITH" }

(* implementation: CLASS WITH *)
| /class_type_declarations: CLASS . TYPE ext list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)
  /structure_item: CLASS . ext list(attribute) virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)
  { "implementation: CLASS WITH" }

(* implementation: CLASS LIDENT EQUAL WITH *)
| /class_fun_binding: EQUAL . class_expr
  { "implementation: CLASS LIDENT EQUAL WITH" }

(* implementation: OBJECT INHERIT OBJECT WITH *)
| /class_simple_expr: OBJECT . list(attribute) class_self_pattern list(text_cstr(class_field)) END
  { "implementation: OBJECT INHERIT OBJECT WITH" }

(* implementation: OBJECT VAL WITH *)
| /class_field: VAL . value list(post_item_attribute)
  { "implementation: OBJECT VAL WITH" }

(* implementation: OBJECT VAL BANG WITH *)
| /value: BANG . list(attribute) mutable_flag LIDENT EQUAL seq_expr
  /value: BANG . list(attribute) mutable_flag LIDENT type_constraint EQUAL seq_expr
  { "implementation: OBJECT VAL BANG WITH" }

(* implementation: OBJECT VAL LBRACKETAT AND RBRACKET WHILE *)
| [_ /value: list(attribute) . virtual_with_mutable_flag LIDENT COLON core_type
     /value: list(attribute) . mutable_flag LIDENT EQUAL seq_expr
     /value: list(attribute) . mutable_flag LIDENT type_constraint EQUAL seq_expr]
  { "implementation: OBJECT VAL LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT VAL VIRTUAL WITH *)
| /virtual_with_mutable_flag: VIRTUAL .
  /virtual_with_mutable_flag: VIRTUAL . MUTABLE
  { "implementation: OBJECT VAL VIRTUAL WITH" }

(* implementation: OBJECT VAL MUTABLE WITH *)
| /mutable_flag: MUTABLE .
  /virtual_with_mutable_flag: MUTABLE . VIRTUAL
  { "implementation: OBJECT VAL MUTABLE WITH" }

(* implementation: OBJECT VAL VIRTUAL LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /value: list(attribute) virtual_with_mutable_flag LIDENT COLON core_type .]
  { "implementation: OBJECT VAL VIRTUAL LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT METHOD WITH *)
| /class_field: METHOD . method_ list(post_item_attribute)
  { "implementation: OBJECT METHOD WITH" }

(* implementation: OBJECT METHOD BANG WITH *)
| /method_: BANG . list(attribute) private_flag LIDENT strict_binding
  /method_: BANG . list(attribute) private_flag LIDENT COLON possibly_poly(core_type) EQUAL seq_expr
  /method_: BANG . list(attribute) private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr
  { "implementation: OBJECT METHOD BANG WITH" }

(* implementation: OBJECT METHOD LBRACKETAT AND RBRACKET WHILE *)
| [_ /method_: list(attribute) . virtual_with_private_flag LIDENT COLON possibly_poly(core_type)
     /method_: list(attribute) . private_flag LIDENT strict_binding
     /method_: list(attribute) . private_flag LIDENT COLON possibly_poly(core_type) EQUAL seq_expr
     /method_: list(attribute) . private_flag LIDENT COLON TYPE nonempty_list(mkrhs(LIDENT)) DOT core_type EQUAL seq_expr]
  { "implementation: OBJECT METHOD LBRACKETAT AND RBRACKET WHILE" }

(* implementation: OBJECT METHOD VIRTUAL WITH *)
| /virtual_with_private_flag: VIRTUAL .
  /virtual_with_private_flag: VIRTUAL . PRIVATE
  { "implementation: OBJECT METHOD VIRTUAL WITH" }

(* implementation: OBJECT METHOD PRIVATE WITH *)
| /private_flag: PRIVATE .
  /virtual_with_private_flag: PRIVATE . VIRTUAL
  { "implementation: OBJECT METHOD PRIVATE WITH" }

(* implementation: OBJECT INITIALIZER WITH *)
| /class_field: INITIALIZER . list(attribute) seq_expr list(post_item_attribute)
  { "implementation: OBJECT INITIALIZER WITH" }

(* implementation: OBJECT INHERIT WITH *)
| /class_field: INHERIT . list(attribute) class_expr option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)
  /class_field: INHERIT . BANG list(attribute) class_expr option(preceded(AS,mkrhs(LIDENT))) list(post_item_attribute)
  { "implementation: OBJECT INHERIT WITH" }

(* implementation: OBJECT INHERIT LPAREN WITH *)
| /class_simple_expr: LPAREN . class_expr RPAREN
  /class_simple_expr: LPAREN . class_expr COLON class_type RPAREN
  { "implementation: OBJECT INHERIT LPAREN WITH" }

(* implementation: OBJECT INHERIT LET WITH *)
| /class_expr: LET . OPEN list(attribute) mod_longident IN class_expr
  /class_expr: LET . OPEN BANG list(attribute) mod_longident IN class_expr
  /let_bindings(no_ext): LET . list(attribute) rec_flag let_binding_body list(post_item_attribute)
  /let_bindings(no_ext): LET . PERCENT attr_id list(attribute) rec_flag let_binding_body list(post_item_attribute)
  { "implementation: OBJECT INHERIT LET WITH" }

(* implementation: OBJECT INHERIT LBRACKET WITH *)
| /class_simple_expr: LBRACKET . reversed_separated_nonempty_llist(COMMA,core_type) RBRACKET class_longident
  { "implementation: OBJECT INHERIT LBRACKET WITH" }

(* implementation: OBJECT INHERIT FUN WITH *)
| /class_expr: FUN . list(attribute) class_fun_def
  { "implementation: OBJECT INHERIT FUN WITH" }

(* implementation: OBJECT INHERIT FUN FALSE WHILE *)
| [_ /class_fun_def: labeled_simple_pattern . MINUSGREATER class_expr
     /class_fun_def: labeled_simple_pattern . class_fun_def]
  { "implementation: OBJECT INHERIT FUN FALSE WHILE" }

(* implementation: OBJECT INHERIT LET LIDENT AND LIDENT VAL *)
| [_ /class_expr: let_bindings(no_ext) . IN class_expr
     /let_bindings(no_ext): let_bindings(no_ext) . and_let_binding]
  { "implementation: OBJECT INHERIT LET LIDENT AND LIDENT VAL" }

(* implementation: OBJECT INHERIT LIDENT WITH *)
| [_ /class_expr: class_simple_expr .
     /class_expr: class_simple_expr . reversed_nonempty_llist(labeled_simple_expr)]
  { "implementation: OBJECT INHERIT LIDENT WITH" }

(* implementation: OBJECT INHERIT FUN FALSE MINUSGREATER QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: class_expr . attribute
     /class_fun_def: labeled_simple_pattern MINUSGREATER class_expr .]
  { "implementation: OBJECT INHERIT FUN FALSE MINUSGREATER QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT INHERIT LIDENT AS WITH *)
| /option(preceded(AS,mkrhs(LIDENT))): AS . LIDENT
  { "implementation: OBJECT INHERIT LIDENT AS WITH" }

(* implementation: OBJECT CONSTRAINT WITH *)
| /class_field: CONSTRAINT . list(attribute) constrain_field list(post_item_attribute)
  { "implementation: OBJECT CONSTRAINT WITH" }

(* implementation: OBJECT QUOTED_STRING_ITEM WITH *)
| [_ /class_field: item_extension . list(post_item_attribute)]
  { "implementation: OBJECT QUOTED_STRING_ITEM WITH" }

(* implementation: OBJECT LBRACKETATATAT AND RBRACKET WITH *)
| [_ /list(text_cstr(class_field)): class_field . list(text_cstr(class_field))]
  { "implementation: OBJECT LBRACKETATATAT AND RBRACKET WITH" }

(* implementation: CLASS LIDENT EQUAL QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: class_expr . attribute
     /class_fun_binding: EQUAL class_expr .]
  { "implementation: CLASS LIDENT EQUAL QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON WITH *)
| /class_fun_binding: COLON . class_type EQUAL class_expr
  { "implementation: CLASS LIDENT COLON WITH" }

(* implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR WITH *)
| [_ /class_expr: class_expr . attribute
     /class_fun_binding: COLON class_type EQUAL class_expr .]
  { "implementation: CLASS LIDENT COLON QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT FALSE WHILE *)
| [_ /class_fun_binding: labeled_simple_pattern . class_fun_binding]
  { "implementation: CLASS LIDENT FALSE WHILE" }

(* implementation: CLASS LIDENT EQUAL LIDENT AND WITH *)
| /list(and_class_declaration): AND . list(attribute) virtual_flag formal_class_parameters LIDENT class_fun_binding list(post_item_attribute) list(and_class_declaration)
  { "implementation: CLASS LIDENT EQUAL LIDENT AND WITH" }

(* interface: CLASS WITH *)
| /class_type_declarations: CLASS . TYPE ext list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)
  /signature_item: CLASS . ext list(attribute) virtual_flag formal_class_parameters LIDENT COLON class_type list(post_item_attribute) list(and_class_description)
  { "interface: CLASS WITH" }

(* implementation: CLASS LBRACKET WITH *)
| /formal_class_parameters: LBRACKET . reversed_separated_nonempty_llist(COMMA,type_parameter) RBRACKET
  { "implementation: CLASS LBRACKET WITH" }

(* implementation: CLASS LIDENT COLON OBJECT WITH *)
| /class_signature: OBJECT . list(attribute) class_self_type list(text_csig(class_sig_field)) END
  { "implementation: CLASS LIDENT COLON OBJECT WITH" }

(* implementation: CLASS LIDENT COLON OBJECT LPAREN WITH *)
| /class_self_type: LPAREN . core_type RPAREN
  { "implementation: CLASS LIDENT COLON OBJECT LPAREN WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL WITH *)
| /class_sig_field: VAL . list(attribute) mutable_virtual_flags LIDENT COLON core_type list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT VAL WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL VIRTUAL WITH *)
| /mutable_virtual_flags: VIRTUAL .
  /mutable_virtual_flags: VIRTUAL . MUTABLE
  { "implementation: CLASS LIDENT COLON OBJECT VAL VIRTUAL WITH" }

(* implementation: CLASS LIDENT COLON OBJECT VAL MUTABLE WITH *)
| /mutable_virtual_flags: MUTABLE .
  /mutable_virtual_flags: MUTABLE . VIRTUAL
  { "implementation: CLASS LIDENT COLON OBJECT VAL MUTABLE WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD WITH *)
| /class_sig_field: METHOD . list(attribute) private_virtual_flags LIDENT COLON possibly_poly(core_type) list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT METHOD WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD VIRTUAL WITH *)
| /private_virtual_flags: VIRTUAL .
  /private_virtual_flags: VIRTUAL . PRIVATE
  { "implementation: CLASS LIDENT COLON OBJECT METHOD VIRTUAL WITH" }

(* implementation: CLASS LIDENT COLON OBJECT METHOD PRIVATE WITH *)
| /private_virtual_flags: PRIVATE .
  /private_virtual_flags: PRIVATE . VIRTUAL
  { "implementation: CLASS LIDENT COLON OBJECT METHOD PRIVATE WITH" }

(* implementation: OBJECT METHOD LIDENT COLON QUOTE LIDENT QUOTE LIDENT WITH *)
| [_ /possibly_poly(core_type): reversed_nonempty_llist(typevar) . DOT core_type
     /reversed_nonempty_llist(typevar): reversed_nonempty_llist(typevar) . QUOTE ident]
  { "implementation: OBJECT METHOD LIDENT COLON QUOTE LIDENT QUOTE LIDENT WITH" }

(* implementation: OBJECT METHOD LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /possibly_poly(core_type): reversed_nonempty_llist(typevar) DOT core_type .]
  { "implementation: OBJECT METHOD LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /possibly_poly(core_type): core_type .]
  { "implementation: OBJECT METHOD LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OBJECT INHERIT WITH *)
| /class_sig_field: INHERIT . list(attribute) class_signature list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT INHERIT WITH" }

(* implementation: CLASS LIDENT COLON LET WITH *)
| /class_signature: LET . OPEN list(attribute) mod_longident IN class_signature
  /class_signature: LET . OPEN BANG list(attribute) mod_longident IN class_signature
  { "implementation: CLASS LIDENT COLON LET WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LBRACKET WITH *)
| /class_signature: LBRACKET . reversed_separated_nonempty_llist(COMMA,core_type) RBRACKET clty_longident
  { "implementation: CLASS TYPE LIDENT EQUAL LBRACKET WITH" }

(* implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /reversed_separated_nonempty_llist(COMMA,core_type): reversed_separated_nonempty_llist(COMMA,core_type) COMMA core_type .]
  { "implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR WITH" }

(* implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /reversed_separated_nonempty_llist(COMMA,core_type): core_type .]
  { "implementation: OBJECT INHERIT LBRACKET QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN BANG UIDENT IN LIDENT WITH *)
| [_ /class_signature: class_signature . attribute
     /class_signature: LET OPEN BANG list(attribute) mod_longident IN class_signature .]
  { "implementation: CLASS LIDENT COLON LET OPEN BANG UIDENT IN LIDENT WITH" }

(* implementation: CLASS LIDENT COLON LET OPEN UIDENT IN LIDENT WITH *)
| [_ /class_signature: class_signature . attribute
     /class_signature: LET OPEN list(attribute) mod_longident IN class_signature .]
  { "implementation: CLASS LIDENT COLON LET OPEN UIDENT IN LIDENT WITH" }

(* implementation: CLASS LIDENT COLON OBJECT CONSTRAINT WITH *)
| /class_sig_field: CONSTRAINT . list(attribute) constrain_field list(post_item_attribute)
  { "implementation: CLASS LIDENT COLON OBJECT CONSTRAINT WITH" }

(* implementation: OBJECT CONSTRAINT QUOTED_STRING_EXPR WITH *)
| [_ /constrain_field: core_type . EQUAL core_type
     /core_type: core_type . attribute]
  { "implementation: OBJECT CONSTRAINT QUOTED_STRING_EXPR WITH" }

(* implementation: CLASS LIDENT COLON OBJECT QUOTED_STRING_ITEM WITH *)
| [_ /class_sig_field: item_extension . list(post_item_attribute)]
  { "implementation: CLASS LIDENT COLON OBJECT QUOTED_STRING_ITEM WITH" }

(* implementation: CLASS LIDENT COLON OBJECT LBRACKETATATAT AND RBRACKET WITH *)
| [_ /list(text_csig(class_sig_field)): class_sig_field . list(text_csig(class_sig_field))]
  { "implementation: CLASS LIDENT COLON OBJECT LBRACKETATATAT AND RBRACKET WITH" }

(* implementation: CLASS TYPE LIDENT EQUAL LIDENT AND WITH *)
| /list(and_class_type_declaration): AND . list(attribute) virtual_flag formal_class_parameters LIDENT EQUAL class_signature list(post_item_attribute) list(and_class_type_declaration)
  { "implementation: CLASS TYPE LIDENT EQUAL LIDENT AND WITH" }

(* implementation: ASSERT LBRACKETAT AND RBRACKET WITH *)
| [_ /list(attribute): attribute . list(attribute)]
  { "implementation: ASSERT LBRACKETAT AND RBRACKET WITH" }

(* implementation: LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  /simple_expr: LPAREN . seq_expr RPAREN
  /simple_expr: LPAREN . seq_expr type_constraint RPAREN
  /simple_expr: LPAREN . MODULE ext list(attribute) module_expr RPAREN
  /simple_expr: LPAREN . MODULE ext list(attribute) module_expr COLON module_type RPAREN
  /val_extra_ident: LPAREN . operator RPAREN
  { "implementation: LPAREN WITH" }

(* implementation: LPAREN PREFIXOP WITH *)
| /operator: PREFIXOP .
  /simple_expr: PREFIXOP . simple_expr
  { "implementation: LPAREN PREFIXOP WITH" }

(* implementation: LBRACKETBAR WITH *)
| /simple_expr: LBRACKETBAR . separated_or_terminated_nonempty_list(SEMI,expr) BARRBRACKET
  /simple_expr: LBRACKETBAR . BARRBRACKET
  { "implementation: LBRACKETBAR WITH" }

(* implementation: OBJECT WITH *)
| /expr: OBJECT . ext list(attribute) class_self_pattern list(text_cstr(class_field)) END
  { "implementation: OBJECT WITH" }

(* implementation: OBJECT LPAREN WITH *)
| /class_self_pattern: LPAREN . pattern RPAREN
  /class_self_pattern: LPAREN . pattern COLON core_type RPAREN
  { "implementation: OBJECT LPAREN WITH" }

(* parse_pattern: PLUS WITH *)
| /signed_constant: PLUS . INT
  /signed_constant: PLUS . FLOAT
  { "parse_pattern: PLUS WITH" }

(* parse_pattern: MINUS WITH *)
| /signed_constant: MINUS . INT
  /signed_constant: MINUS . FLOAT
  { "parse_pattern: MINUS WITH" }

(* parse_pattern: LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  /simple_pattern_not_ident: LPAREN . pattern RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name COLON module_type RPAREN
  /simple_pattern_not_ident: LPAREN . pattern COLON core_type RPAREN
  /val_extra_ident: LPAREN . operator RPAREN
  { "parse_pattern: LPAREN WITH" }

(* parse_pattern: LPAREN PLUS WITH *)
| /operator: PLUS .
  /signed_constant: PLUS . INT
  /signed_constant: PLUS . FLOAT
  { "parse_pattern: LPAREN PLUS WITH" }

(* interface: INCLUDE MODULE WITH *)
| /module_type: MODULE . TYPE OF list(attribute) module_expr
  { "interface: INCLUDE MODULE WITH" }

(* implementation: INCLUDE STRUCT WITH *)
| /module_expr: STRUCT . list(attribute) structure END
  { "implementation: INCLUDE STRUCT WITH" }

(* implementation: SEMISEMI WITH *)
| /list(structure_element): SEMISEMI . list(structure_element)
  /list(structure_element): SEMISEMI . seq_expr list(post_item_attribute) list(structure_element)
  { "implementation: SEMISEMI WITH" }

(* implementation: OPEN WITH *)
| /open_declaration: OPEN . ext list(attribute) module_expr list(post_item_attribute)
  /open_declaration: OPEN . BANG ext list(attribute) module_expr list(post_item_attribute)
  { "implementation: OPEN WITH" }

(* implementation: INCLUDE LPAREN WITH *)
| /paren_module_expr: LPAREN . module_expr COLON module_type RPAREN
  /paren_module_expr: LPAREN . module_expr RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr COLON module_type RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr COLON module_type COLONGREATER module_type RPAREN
  /paren_module_expr: LPAREN . VAL list(attribute) expr COLONGREATER module_type RPAREN
  { "implementation: INCLUDE LPAREN WITH" }

(* implementation: MATCH WITH *)
| /expr: MATCH . ext list(attribute) seq_expr WITH reversed_preceded_or_separated_nonempty_llist(BAR,match_case)
  { "implementation: MATCH WITH" }

(* implementation: LIDENT WHILE *)
| /expr: LIDENT . LESSMINUS expr
  /val_ident: LIDENT .
  { "implementation: LIDENT WHILE" }

(* implementation: LETOP WITH *)
| /expr: LETOP . letop_bindings IN seq_expr
  { "implementation: LETOP WITH" }

(* parse_pattern: LBRACKETBAR WITH *)
| /simple_delimited_pattern: LBRACKETBAR . separated_or_terminated_nonempty_list(SEMI,pattern) BARRBRACKET
  /simple_delimited_pattern: LBRACKETBAR . BARRBRACKET
  { "parse_pattern: LBRACKETBAR WITH" }

(* parse_pattern: LBRACKET WITH *)
| /constr_extra_nonprefix_ident: LBRACKET . RBRACKET
  /simple_delimited_pattern: LBRACKET . separated_or_terminated_nonempty_list(SEMI,pattern) RBRACKET
  { "parse_pattern: LBRACKET WITH" }

(* parse_pattern: LBRACE WITH *)
| /simple_delimited_pattern: LBRACE . listx(SEMI,record_pat_field,UNDERSCORE) RBRACE
  { "parse_pattern: LBRACE WITH" }

(* parse_pattern: LBRACE LIDENT WITH *)
| [_ /listx(SEMI,record_pat_field,UNDERSCORE): label_longident . option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern))
     /listx(SEMI,record_pat_field,UNDERSCORE): label_longident . option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI
     /listx(SEMI,record_pat_field,UNDERSCORE): label_longident . option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI UNDERSCORE option(SEMI)
     /listx(SEMI,record_pat_field,UNDERSCORE): label_longident . option(preceded(COLON,core_type)) option(preceded(EQUAL,pattern)) SEMI listx(SEMI,record_pat_field,UNDERSCORE)]
  { "parse_pattern: LBRACE LIDENT WITH" }

(* parse_pattern: LBRACE LIDENT COLON WITH *)
| /option(preceded(COLON,core_type)): COLON . core_type
  { "parse_pattern: LBRACE LIDENT COLON WITH" }

(* parse_core_type: LBRACKETLESS WITH *)
| /atomic_type: LBRACKETLESS . option(BAR) reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /atomic_type: LBRACKETLESS . option(BAR) reversed_separated_nonempty_llist(BAR,row_field) GREATER reversed_nonempty_llist(name_tag) RBRACKET
  { "parse_core_type: LBRACKETLESS WITH" }

(* parse_core_type: LBRACKETGREATER WITH *)
| /atomic_type: LBRACKETGREATER . option(BAR) reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /atomic_type: LBRACKETGREATER . RBRACKET
  { "parse_core_type: LBRACKETGREATER WITH" }

(* parse_core_type: LBRACKET WITH *)
| /atomic_type: LBRACKET . tag_field RBRACKET
  /atomic_type: LBRACKET . BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /atomic_type: LBRACKET . row_field BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  { "parse_core_type: LBRACKET WITH" }

(* parse_core_type: HASH WITH *)
| /atomic_type: HASH . clty_longident
  { "parse_core_type: HASH WITH" }

(* parse_core_type: UIDENT WITH *)
| [_ /mk_longident(mod_ext_longident,LIDENT): mod_ext_longident . DOT LIDENT
     /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN]
  { "parse_core_type: UIDENT WITH" }

(* implementation: BACKQUOTE WITH *)
| /name_tag: BACKQUOTE . ident
  { "implementation: BACKQUOTE WITH" }

(* parse_core_type: QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /reversed_separated_nontrivial_llist(STAR,atomic_type): reversed_separated_nontrivial_llist(STAR,atomic_type) STAR atomic_type .]
  { "parse_core_type: QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR WHILE" }

(* parse_core_type: OPTLABEL WITH *)
| [_ /function_type: optlabel . tuple_type MINUSGREATER function_type]
  { "parse_core_type: OPTLABEL WITH" }

(* parse_core_type: QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /reversed_separated_nontrivial_llist(STAR,atomic_type): atomic_type . STAR atomic_type
     /tuple_type: atomic_type .]
  { "parse_core_type: QUOTED_STRING_EXPR WHILE" }

(* parse_core_type: QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /reversed_separated_nontrivial_llist(STAR,atomic_type): atomic_type STAR atomic_type .]
  { "parse_core_type: QUOTED_STRING_EXPR STAR QUOTED_STRING_EXPR WHILE" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT WITH *)
| [_ /tag_field: name_tag . OF opt_ampersand reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr) list(attribute)
     /tag_field: name_tag . list(attribute)]
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT WITH" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT OF QUOTED_STRING_EXPR AMPERSAND QUOTED_STRING_EXPR WITH *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr): reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr) AMPERSAND alias_type .]
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT OF QUOTED_STRING_EXPR AMPERSAND QUOTED_STRING_EXPR WITH" }

(* parse_core_type: LBRACKET BACKQUOTE LIDENT OF QUOTED_STRING_EXPR WITH *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /reversed_separated_nonempty_llist(AMPERSAND,core_type_no_attr): alias_type .]
  { "parse_core_type: LBRACKET BACKQUOTE LIDENT OF QUOTED_STRING_EXPR WITH" }

(* parse_core_type: LBRACKET QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /row_field: core_type .]
  { "parse_core_type: LBRACKET QUOTED_STRING_EXPR WITH" }

(* parse_core_type: QUOTED_STRING_EXPR AMPERSAND *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /core_type: alias_type .]
  { "parse_core_type: QUOTED_STRING_EXPR AMPERSAND" }

(* parse_pattern: LBRACE LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /option(preceded(COLON,core_type)): COLON core_type .]
  { "parse_pattern: LBRACE LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* parse_pattern: LBRACE LIDENT EQUAL WITH *)
| /option(preceded(EQUAL,pattern)): EQUAL . pattern
  { "parse_pattern: LBRACE LIDENT EQUAL WITH" }

(* parse_pattern: LAZY WITH *)
| /pattern_gen: LAZY . ext list(attribute) simple_pattern
  { "parse_pattern: LAZY WITH" }

(* parse_pattern: HASH WITH *)
| /simple_pattern_not_ident: HASH . type_longident
  { "parse_pattern: HASH WITH" }

(* parse_pattern: CHAR WITH *)
| [_ /simple_pattern_not_ident: signed_constant .
     /simple_pattern_not_ident: signed_constant . DOTDOT signed_constant]
  { "parse_pattern: CHAR WITH" }

(* parse_pattern: UIDENT WITH *)
| [_ /constr_longident: mod_longident .
     /constr_longident: mod_longident . DOT LPAREN COLONCOLON RPAREN
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /simple_pattern_not_ident: mod_longident . DOT simple_delimited_pattern
     /simple_pattern_not_ident: mod_longident . DOT LBRACKET RBRACKET
     /simple_pattern_not_ident: mod_longident . DOT LPAREN RPAREN
     /simple_pattern_not_ident: mod_longident . DOT LPAREN pattern RPAREN]
  { "parse_pattern: UIDENT WITH" }

(* parse_pattern: EXCEPTION WITH *)
| /pattern: EXCEPTION . ext list(attribute) pattern
  { "parse_pattern: EXCEPTION WITH" }

(* parse_pattern: BACKQUOTE LIDENT WITH *)
| [_ /pattern_gen: name_tag . pattern
     /simple_pattern_not_ident: name_tag .]
  { "parse_pattern: BACKQUOTE LIDENT WITH" }

(* parse_pattern: FALSE TILDE *)
| [_ /pattern_gen: constr_longident . pattern
     /pattern_gen: constr_longident . LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN simple_pattern
     /simple_pattern_not_ident: constr_longident .]
  { "parse_pattern: FALSE TILDE" }

(* parse_pattern: FALSE LPAREN TYPE LIDENT WITH *)
| /nonempty_list(mkrhs(LIDENT)): LIDENT .
  /nonempty_list(mkrhs(LIDENT)): LIDENT . nonempty_list(mkrhs(LIDENT))
  { "parse_pattern: FALSE LPAREN TYPE LIDENT WITH" }

(* parse_pattern: LPAREN MINUS WITH *)
| /operator: MINUS .
  /signed_constant: MINUS . INT
  /signed_constant: MINUS . FLOAT
  { "parse_pattern: LPAREN MINUS WITH" }

(* parse_pattern: FALSE COMMA QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /pattern_comma_list(pattern): pattern COMMA pattern .]
  { "parse_pattern: FALSE COMMA QUOTED_STRING_EXPR WHILE" }

(* parse_pattern: LBRACKET QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /separated_or_terminated_nonempty_list(SEMI,pattern): pattern .
     /separated_or_terminated_nonempty_list(SEMI,pattern): pattern . SEMI
     /separated_or_terminated_nonempty_list(SEMI,pattern): pattern . SEMI separated_or_terminated_nonempty_list(SEMI,pattern)]
  { "parse_pattern: LBRACKET QUOTED_STRING_EXPR WHILE" }

(* implementation: FUN TILDE WITH *)
| /labeled_simple_pattern: TILDE . LPAREN label_let_pattern RPAREN
  /labeled_simple_pattern: TILDE . LIDENT
  { "implementation: FUN TILDE WITH" }

(* implementation: FUN QUESTION LPAREN LIDENT WITH *)
| /label_let_pattern: LIDENT .
  /label_let_pattern: LIDENT . COLON core_type
  { "implementation: FUN QUESTION LPAREN LIDENT WITH" }

(* implementation: FUN QUESTION LPAREN LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /label_let_pattern: LIDENT COLON core_type .]
  { "implementation: FUN QUESTION LPAREN LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: FUN QUESTION WITH *)
| /labeled_simple_pattern: QUESTION . LPAREN label_let_pattern option(preceded(EQUAL,seq_expr)) RPAREN
  /labeled_simple_pattern: QUESTION . LIDENT
  { "implementation: FUN QUESTION WITH" }

(* implementation: FUN OPTLABEL LPAREN FALSE EQUAL WITH *)
| /option(preceded(EQUAL,seq_expr)): EQUAL . seq_expr
  { "implementation: FUN OPTLABEL LPAREN FALSE EQUAL WITH" }

(* implementation: LET WITH *)
| /expr: LET . MODULE ext list(attribute) module_name module_binding_body IN seq_expr
  /expr: LET . EXCEPTION ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) IN seq_expr
  /expr: LET . OPEN ext list(attribute) module_expr IN seq_expr
  /expr: LET . OPEN BANG ext list(attribute) module_expr IN seq_expr
  /let_bindings(ext): LET . ext list(attribute) rec_flag let_binding_body list(post_item_attribute)
  { "implementation: LET WITH" }

(* implementation: INCLUDE FUNCTOR WITH *)
| /module_expr: FUNCTOR . list(attribute) functor_args MINUSGREATER module_expr
  { "implementation: INCLUDE FUNCTOR WITH" }

(* implementation: MODULE UIDENT LPAREN WITH *)
| /functor_arg: LPAREN . RPAREN
  /functor_arg: LPAREN . module_name COLON module_type RPAREN
  { "implementation: MODULE UIDENT LPAREN WITH" }

(* interface: INCLUDE LPAREN WITH *)
| /module_type: LPAREN . module_type RPAREN
  { "interface: INCLUDE LPAREN WITH" }

(* interface: INCLUDE FUNCTOR WITH *)
| /module_type: FUNCTOR . list(attribute) functor_args MINUSGREATER module_type
  { "interface: INCLUDE FUNCTOR WITH" }

(* implementation: INCLUDE FUNCTOR LPAREN RPAREN WITH *)
| [_ /functor_args: reversed_nonempty_llist(functor_arg) .
     /reversed_nonempty_llist(functor_arg): reversed_nonempty_llist(functor_arg) . functor_arg]
  { "implementation: INCLUDE FUNCTOR LPAREN RPAREN WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE WITH *)
| /with_constraint: TYPE . type_parameters label_longident with_type_binder alias_type reversed_llist(preceded(CONSTRAINT,constrain))
  /with_constraint: TYPE . type_parameters label_longident COLONEQUAL alias_type
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT EQUAL WITH *)
| /with_type_binder: EQUAL .
  /with_type_binder: EQUAL . PRIVATE
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT EQUAL WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT COLONEQUAL QUOTED_STRING_EXPR COMMA *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /with_constraint: TYPE type_parameters label_longident COLONEQUAL alias_type .]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH TYPE LIDENT COLONEQUAL QUOTED_STRING_EXPR COMMA" }

(* implementation: TYPE LIDENT CONSTRAINT QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR COMMA *)
| [_ /core_type: core_type . attribute
     /reversed_llist(preceded(CONSTRAINT,constrain)): reversed_llist(preceded(CONSTRAINT,constrain)) CONSTRAINT core_type EQUAL core_type .]
  { "implementation: TYPE LIDENT CONSTRAINT QUOTED_STRING_EXPR EQUAL QUOTED_STRING_EXPR COMMA" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE WITH *)
| /with_constraint: MODULE . mod_longident EQUAL mod_ext_longident
  /with_constraint: MODULE . mod_longident COLONEQUAL mod_ext_longident
  /with_constraint: MODULE . TYPE mty_longident EQUAL module_type
  /with_constraint: MODULE . TYPE mty_longident COLONEQUAL module_type
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT EQUAL QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /with_constraint: MODULE TYPE mty_longident EQUAL module_type .]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT EQUAL QUOTED_STRING_EXPR WHILE" }

(* parse_mty_longident: UIDENT LPAREN UIDENT RPAREN WITH *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mk_longident(mod_ext_longident,ident): mod_ext_longident . DOT ident
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN]
  { "parse_mty_longident: UIDENT LPAREN UIDENT RPAREN WITH" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT COLONEQUAL QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /with_constraint: MODULE TYPE mty_longident COLONEQUAL module_type .]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE TYPE UIDENT COLONEQUAL QUOTED_STRING_EXPR WHILE" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT EQUAL UIDENT WHILE *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN
     /with_constraint: MODULE mod_longident EQUAL mod_ext_longident .]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT EQUAL UIDENT WHILE" }

(* interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT COLONEQUAL UIDENT WHILE *)
| [_ /mk_longident(mod_ext_longident,UIDENT): mod_ext_longident . DOT UIDENT
     /mod_ext_longident: mod_ext_longident . LPAREN mod_ext_longident RPAREN
     /with_constraint: MODULE mod_longident COLONEQUAL mod_ext_longident .]
  { "interface: INCLUDE QUOTED_STRING_EXPR WITH MODULE UIDENT COLONEQUAL UIDENT WHILE" }

(* implementation: INCLUDE UIDENT WHILE *)
| [_ /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /module_expr: mod_longident .]
  { "implementation: INCLUDE UIDENT WHILE" }

(* implementation: LBRACKET WITH *)
| /constr_extra_nonprefix_ident: LBRACKET . RBRACKET
  /simple_expr: LBRACKET . separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
  { "implementation: LBRACKET WITH" }

(* implementation: LBRACELESS WITH *)
| /simple_expr: LBRACELESS . separated_or_terminated_nonempty_list(SEMI,object_expr_field) GREATERRBRACE
  /simple_expr: LBRACELESS . GREATERRBRACE
  { "implementation: LBRACELESS WITH" }

(* implementation: LBRACELESS LIDENT WITH *)
| /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT . option(preceded(EQUAL,expr))
  /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT . option(preceded(EQUAL,expr)) SEMI
  /separated_or_terminated_nonempty_list(SEMI,object_expr_field): LIDENT . option(preceded(EQUAL,expr)) SEMI separated_or_terminated_nonempty_list(SEMI,object_expr_field)
  { "implementation: LBRACELESS LIDENT WITH" }

(* implementation: LBRACELESS LIDENT EQUAL WITH *)
| /option(preceded(EQUAL,expr)): EQUAL . expr
  { "implementation: LBRACELESS LIDENT EQUAL WITH" }

(* implementation: LBRACE WITH *)
| /simple_expr: LBRACE . record_expr_content RBRACE
  { "implementation: LBRACE WITH" }

(* implementation: LBRACE LIDENT WHILE *)
| /mk_longident(mod_longident,LIDENT): LIDENT .
  /val_ident: LIDENT .
  { "implementation: LBRACE LIDENT WHILE" }

(* implementation: BEGIN WITH *)
| /simple_expr: BEGIN . ext list(attribute) seq_expr END
  /simple_expr: BEGIN . ext list(attribute) END
  { "implementation: BEGIN WITH" }

(* implementation: LAZY WITH *)
| /expr: LAZY . ext list(attribute) simple_expr
  { "implementation: LAZY WITH" }

(* implementation: BANG WITH *)
| /simple_expr: BANG . simple_expr
  { "implementation: BANG WITH" }

(* implementation: UIDENT WHILE *)
| [_ /constr_longident: mod_longident .
     /constr_longident: mod_longident . DOT LPAREN COLONCOLON RPAREN
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /mk_longident(mod_longident,val_ident): mod_longident . DOT val_ident
     /simple_expr: mod_longident . DOT LPAREN seq_expr RPAREN
     /simple_expr: mod_longident . DOT LBRACELESS separated_or_terminated_nonempty_list(SEMI,object_expr_field) GREATERRBRACE
     /simple_expr: mod_longident . DOT LPAREN RPAREN
     /simple_expr: mod_longident . DOT LBRACE record_expr_content RBRACE
     /simple_expr: mod_longident . DOT LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,expr) BARRBRACKET
     /simple_expr: mod_longident . DOT LBRACKETBAR BARRBRACKET
     /simple_expr: mod_longident . DOT LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: mod_longident . DOT LBRACKET RBRACKET
     /simple_expr: mod_longident . DOT LPAREN MODULE ext list(attribute) module_expr COLON module_type RPAREN]
  { "implementation: UIDENT WHILE" }

(* implementation: LPAREN PLUSDOT WITH *)
| /additive: PLUSDOT .
  /operator: PLUSDOT .
  { "implementation: LPAREN PLUSDOT WITH" }

(* implementation: LPAREN PLUS WITH *)
| /additive: PLUS .
  /operator: PLUS .
  { "implementation: LPAREN PLUS WITH" }

(* implementation: LPAREN MINUSDOT WITH *)
| /operator: MINUSDOT .
  /subtractive: MINUSDOT .
  { "implementation: LPAREN MINUSDOT WITH" }

(* implementation: LPAREN MINUS WITH *)
| /operator: MINUS .
  /subtractive: MINUS .
  { "implementation: LPAREN MINUS WITH" }

(* implementation: LPAREN LETOP WITH *)
| /expr: LETOP . letop_bindings IN seq_expr
  /operator: LETOP .
  { "implementation: LPAREN LETOP WITH" }

(* implementation: LETOP LIDENT WHILE *)
| [_ /letop_binding_body: simple_pattern . COLON core_type EQUAL seq_expr
     /pattern_gen: simple_pattern .]
  { "implementation: LETOP LIDENT WHILE" }

(* implementation: IF WITH *)
| /expr: IF . ext list(attribute) seq_expr THEN expr ELSE expr
  /expr: IF . ext list(attribute) seq_expr THEN expr
  { "implementation: IF WITH" }

(* implementation: FUNCTION WITH *)
| /expr: FUNCTION . ext list(attribute) reversed_preceded_or_separated_nonempty_llist(BAR,match_case)
  { "implementation: FUNCTION WITH" }

(* implementation: FUNCTION BAR WITH *)
| /reversed_preceded_or_separated_nonempty_llist(BAR,match_case): BAR . match_case
  { "implementation: FUNCTION BAR WITH" }

(* implementation: FUNCTION QUOTED_STRING_EXPR WHILE *)
| [_ /match_case: pattern . MINUSGREATER seq_expr
     /match_case: pattern . WHEN seq_expr MINUSGREATER seq_expr
     /match_case: pattern . MINUSGREATER DOT
     /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern]
  { "implementation: FUNCTION QUOTED_STRING_EXPR WHILE" }

(* implementation: FUN WITH *)
| /expr: FUN . ext list(attribute) labeled_simple_pattern fun_def
  /expr: FUN . ext list(attribute) LPAREN TYPE nonempty_list(mkrhs(LIDENT)) RPAREN fun_def
  { "implementation: FUN WITH" }

(* implementation: FUN OPTLABEL WITH *)
| /labeled_simple_pattern: OPTLABEL . LPAREN let_pattern option(preceded(EQUAL,seq_expr)) RPAREN
  /labeled_simple_pattern: OPTLABEL . pattern_var
  { "implementation: FUN OPTLABEL WITH" }

(* implementation: FUN OPTLABEL LPAREN QUOTED_STRING_EXPR WHILE *)
| [_ /let_pattern: pattern .
     /let_pattern: pattern . COLON core_type
     /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern]
  { "implementation: FUN OPTLABEL LPAREN QUOTED_STRING_EXPR WHILE" }

(* implementation: FUN OPTLABEL LPAREN FALSE COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /let_pattern: pattern COLON core_type .]
  { "implementation: FUN OPTLABEL LPAREN FALSE COLON QUOTED_STRING_EXPR WITH" }

(* implementation: FUN FALSE MINUSGREATER WITH *)
| /fun_def: MINUSGREATER . seq_expr
  { "implementation: FUN FALSE MINUSGREATER WITH" }

(* implementation: FOR WITH *)
| /expr: FOR . ext list(attribute) pattern EQUAL seq_expr direction_flag seq_expr DO seq_expr DONE
  { "implementation: FOR WITH" }

(* implementation: ASSERT WITH *)
| /expr: ASSERT . ext list(attribute) simple_expr
  { "implementation: ASSERT WITH" }

(* implementation: MINUS WITH *)
| [_ /expr: subtractive . expr]
  { "implementation: MINUS WITH" }

(* implementation: UIDENT TILDE WITH *)
| /labeled_simple_expr: TILDE . LIDENT
  { "implementation: UIDENT TILDE WITH" }

(* implementation: UIDENT QUESTION WITH *)
| /labeled_simple_expr: QUESTION . LIDENT
  { "implementation: UIDENT QUESTION WITH" }

(* implementation: UIDENT OPTLABEL WITH *)
| /labeled_simple_expr: OPTLABEL . simple_expr
  { "implementation: UIDENT OPTLABEL WITH" }

(* implementation: CHAR CHAR WHILE *)
| [_ /labeled_simple_expr: simple_expr .
     /simple_expr: simple_expr . DOT LPAREN seq_expr RPAREN
     /simple_expr: simple_expr . DOT LBRACE seq_expr RBRACE
     /simple_expr: simple_expr . DOT LBRACKET seq_expr RBRACKET
     /simple_expr: simple_expr . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT label_longident
     /simple_expr: simple_expr . HASH LIDENT
     /simple_expr: simple_expr . HASHOP simple_expr]
  { "implementation: CHAR CHAR WHILE" }

(* parse_expression: LET LIDENT VAL *)
| [_ /expr: let_bindings(ext) . IN seq_expr
     /let_bindings(ext): let_bindings(ext) . and_let_binding]
  { "parse_expression: LET LIDENT VAL" }

(* implementation: PLUS WITH *)
| [_ /expr: additive . expr]
  { "implementation: PLUS WITH" }

(* implementation: UIDENT COMMA UIDENT AS *)
| [_ /expr: expr . INFIXOP0 expr
     /expr: expr . INFIXOP1 expr
     /expr: expr . INFIXOP2 expr
     /expr: expr . INFIXOP3 expr
     /expr: expr . INFIXOP4 expr
     /expr: expr . PLUS expr
     /expr: expr . PLUSDOT expr
     /expr: expr . PLUSEQ expr
     /expr: expr . MINUS expr
     /expr: expr . MINUSDOT expr
     /expr: expr . STAR expr
     /expr: expr . PERCENT expr
     /expr: expr . EQUAL expr
     /expr: expr . LESS expr
     /expr: expr . GREATER expr
     /expr: expr . OR expr
     /expr: expr . BARBAR expr
     /expr: expr . AMPERSAND expr
     /expr: expr . AMPERAMPER expr
     /expr: expr . COLONEQUAL expr
     /expr: expr . COLONCOLON expr
     /expr: expr . attribute
     /reversed_separated_nontrivial_llist(COMMA,expr): expr . COMMA expr
     /reversed_separated_nontrivial_llist(COMMA,expr): expr COMMA expr .]
  { "implementation: UIDENT COMMA UIDENT AS" }

(* implementation: LET LIDENT AND WITH *)
| /and_let_binding: AND . list(attribute) let_binding_body list(post_item_attribute)
  { "implementation: LET LIDENT AND WITH" }

(* implementation: LETOP LIDENT LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  /simple_pattern_not_ident: LPAREN . pattern RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name COLON module_type RPAREN
  /simple_pattern_not_ident: LPAREN . pattern COLON core_type RPAREN
  /strict_binding: LPAREN . TYPE nonempty_list(mkrhs(LIDENT)) RPAREN fun_binding
  /val_extra_ident: LPAREN . operator RPAREN
  { "implementation: LETOP LIDENT LPAREN WITH" }

(* implementation: FUN LABEL WITH *)
| /labeled_simple_pattern: LABEL . simple_pattern
  { "implementation: FUN LABEL WITH" }

(* implementation: LETOP LIDENT EQUAL WITH *)
| /strict_binding: EQUAL . seq_expr
  { "implementation: LETOP LIDENT EQUAL WITH" }

(* implementation: LBRACE LIDENT COLONGREATER WITH *)
| /type_constraint: COLONGREATER . core_type
  { "implementation: LBRACE LIDENT COLONGREATER WITH" }

(* implementation: LBRACE LIDENT COLONGREATER QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /type_constraint: COLONGREATER core_type .]
  { "implementation: LBRACE LIDENT COLONGREATER QUOTED_STRING_EXPR WITH" }

(* implementation: LBRACE LIDENT COLON WITH *)
| /type_constraint: COLON . core_type
  /type_constraint: COLON . core_type COLONGREATER core_type
  { "implementation: LBRACE LIDENT COLON WITH" }

(* implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR COLONGREATER QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /type_constraint: COLON core_type COLONGREATER core_type .]
  { "implementation: LBRACE LIDENT COLON QUOTED_STRING_EXPR COLONGREATER QUOTED_STRING_EXPR WITH" }

(* implementation: LETOP LIDENT FALSE COLON QUOTED_STRING_EXPR RBRACE *)
| [_ /fun_binding: type_constraint . EQUAL seq_expr]
  { "implementation: LETOP LIDENT FALSE COLON QUOTED_STRING_EXPR RBRACE" }

(* implementation: LETOP LIDENT FALSE WHILE *)
| [_ /strict_binding: labeled_simple_pattern . fun_binding]
  { "implementation: LETOP LIDENT FALSE WHILE" }

(* implementation: LET QUOTED_STRING_EXPR WHILE *)
| [_ /let_binding_body_no_punning: pattern_no_exn . EQUAL seq_expr
     /pattern_comma_list(pattern_no_exn): pattern_no_exn . COMMA pattern
     /pattern_no_exn: pattern_no_exn . COLONCOLON pattern
     /pattern_no_exn: pattern_no_exn . attribute
     /pattern_no_exn: pattern_no_exn . AS val_ident
     /pattern_no_exn: pattern_no_exn . BAR pattern]
  { "implementation: LET QUOTED_STRING_EXPR WHILE" }

(* implementation: LETOP LIDENT COMMA QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /pattern_comma_list(pattern_no_exn): pattern_no_exn COMMA pattern .]
  { "implementation: LETOP LIDENT COMMA QUOTED_STRING_EXPR WHILE" }

(* implementation: LETOP LIDENT COLONCOLON QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /pattern_no_exn: pattern_no_exn COLONCOLON pattern .]
  { "implementation: LETOP LIDENT COLONCOLON QUOTED_STRING_EXPR WHILE" }

(* implementation: LETOP LIDENT BAR QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /pattern_no_exn: pattern_no_exn BAR pattern .]
  { "implementation: LETOP LIDENT BAR QUOTED_STRING_EXPR WHILE" }

(* implementation: LETOP LIDENT COMMA FALSE COMMA QUOTED_STRING_EXPR WHILE *)
| [_ /pattern: pattern . COLONCOLON pattern
     /pattern: pattern . attribute
     /pattern: pattern . AS val_ident
     /pattern: pattern . BAR pattern
     /pattern_comma_list(pattern): pattern . COMMA pattern
     /pattern_comma_list(pattern_no_exn): pattern_comma_list(pattern_no_exn) COMMA pattern .]
  { "implementation: LETOP LIDENT COMMA FALSE COMMA QUOTED_STRING_EXPR WHILE" }

(* implementation: QUOTED_STRING_ITEM LBRACKETATAT AND RBRACKET WITH *)
| [_ /list(post_item_attribute): post_item_attribute . list(post_item_attribute)]
  { "implementation: QUOTED_STRING_ITEM LBRACKETATAT AND RBRACKET WITH" }

(* implementation: LBRACKET UIDENT VAL *)
| [_ /expr: expr . INFIXOP0 expr
     /expr: expr . INFIXOP1 expr
     /expr: expr . INFIXOP2 expr
     /expr: expr . INFIXOP3 expr
     /expr: expr . INFIXOP4 expr
     /expr: expr . PLUS expr
     /expr: expr . PLUSDOT expr
     /expr: expr . PLUSEQ expr
     /expr: expr . MINUS expr
     /expr: expr . MINUSDOT expr
     /expr: expr . STAR expr
     /expr: expr . PERCENT expr
     /expr: expr . EQUAL expr
     /expr: expr . LESS expr
     /expr: expr . GREATER expr
     /expr: expr . OR expr
     /expr: expr . BARBAR expr
     /expr: expr . AMPERSAND expr
     /expr: expr . AMPERAMPER expr
     /expr: expr . COLONEQUAL expr
     /expr: expr . COLONCOLON expr
     /expr: expr . attribute
     /reversed_separated_nontrivial_llist(COMMA,expr): expr . COMMA expr
     /separated_or_terminated_nonempty_list(SEMI,expr): expr .
     /separated_or_terminated_nonempty_list(SEMI,expr): expr . SEMI
     /separated_or_terminated_nonempty_list(SEMI,expr): expr . SEMI separated_or_terminated_nonempty_list(SEMI,expr)]
  { "implementation: LBRACKET UIDENT VAL" }

(* implementation: UIDENT LABEL WITH *)
| /labeled_simple_expr: LABEL . simple_expr
  { "implementation: UIDENT LABEL WITH" }

(* implementation: FUN FALSE LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  /fun_def: LPAREN . TYPE nonempty_list(mkrhs(LIDENT)) RPAREN fun_def
  /simple_pattern_not_ident: LPAREN . pattern RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name RPAREN
  /simple_pattern_not_ident: LPAREN . MODULE ext list(attribute) module_name COLON module_type RPAREN
  /simple_pattern_not_ident: LPAREN . pattern COLON core_type RPAREN
  /val_extra_ident: LPAREN . operator RPAREN
  { "implementation: FUN FALSE LPAREN WITH" }

(* implementation: FUN FALSE COLON WITH *)
| /fun_def: COLON . atomic_type MINUSGREATER seq_expr
  { "implementation: FUN FALSE COLON WITH" }

(* implementation: FUN FALSE FALSE WHILE *)
| [_ /fun_def: labeled_simple_pattern . fun_def]
  { "implementation: FUN FALSE FALSE WHILE" }

(* implementation: LETOP FALSE QUOTED_STRING_EXPR WHILE *)
| [_ /letop_binding_body: pattern_no_exn . EQUAL seq_expr
     /pattern_comma_list(pattern_no_exn): pattern_no_exn . COMMA pattern
     /pattern_no_exn: pattern_no_exn . COLONCOLON pattern
     /pattern_no_exn: pattern_no_exn . attribute
     /pattern_no_exn: pattern_no_exn . AS val_ident
     /pattern_no_exn: pattern_no_exn . BAR pattern]
  { "implementation: LETOP FALSE QUOTED_STRING_EXPR WHILE" }

(* implementation: LPAREN BANG WITH *)
| /operator: BANG .
  /simple_expr: BANG . simple_expr
  { "implementation: LPAREN BANG WITH" }

(* implementation: LBRACE CHAR VAL *)
| [_ /record_expr_content: simple_expr . WITH separated_or_terminated_nonempty_list(SEMI,record_expr_field)
     /simple_expr: simple_expr . DOT LPAREN seq_expr RPAREN
     /simple_expr: simple_expr . DOT LBRACE seq_expr RBRACE
     /simple_expr: simple_expr . DOT LBRACKET seq_expr RBRACKET
     /simple_expr: simple_expr . DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOT mod_longident DOTOP LPAREN separated_or_terminated_nonempty_list(SEMI,expr) RPAREN
     /simple_expr: simple_expr . DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACE separated_or_terminated_nonempty_list(SEMI,expr) RBRACE
     /simple_expr: simple_expr . DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT mod_longident DOTOP LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: simple_expr . DOT label_longident
     /simple_expr: simple_expr . HASH LIDENT
     /simple_expr: simple_expr . HASHOP simple_expr]
  { "implementation: LBRACE CHAR VAL" }

(* implementation: LBRACE CHAR WITH LIDENT WITH *)
| [_ /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident . option(type_constraint) option(preceded(EQUAL,expr))
     /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident . option(type_constraint) option(preceded(EQUAL,expr)) SEMI
     /separated_or_terminated_nonempty_list(SEMI,record_expr_field): label_longident . option(type_constraint) option(preceded(EQUAL,expr)) SEMI separated_or_terminated_nonempty_list(SEMI,record_expr_field)]
  { "implementation: LBRACE CHAR WITH LIDENT WITH" }

(* implementation: LBRACE UIDENT WHILE *)
| [_ /constr_longident: mod_longident .
     /constr_longident: mod_longident . DOT LPAREN COLONCOLON RPAREN
     /mk_longident(mod_longident,LIDENT): mod_longident . DOT LIDENT
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT
     /mk_longident(mod_longident,val_ident): mod_longident . DOT val_ident
     /simple_expr: mod_longident . DOT LPAREN seq_expr RPAREN
     /simple_expr: mod_longident . DOT LBRACELESS separated_or_terminated_nonempty_list(SEMI,object_expr_field) GREATERRBRACE
     /simple_expr: mod_longident . DOT LPAREN RPAREN
     /simple_expr: mod_longident . DOT LBRACE record_expr_content RBRACE
     /simple_expr: mod_longident . DOT LBRACKETBAR separated_or_terminated_nonempty_list(SEMI,expr) BARRBRACKET
     /simple_expr: mod_longident . DOT LBRACKETBAR BARRBRACKET
     /simple_expr: mod_longident . DOT LBRACKET separated_or_terminated_nonempty_list(SEMI,expr) RBRACKET
     /simple_expr: mod_longident . DOT LBRACKET RBRACKET
     /simple_expr: mod_longident . DOT LPAREN MODULE ext list(attribute) module_expr COLON module_type RPAREN]
  { "implementation: LBRACE UIDENT WHILE" }

(* implementation: MODULE UIDENT EQUAL WITH *)
| /module_binding_body: EQUAL . module_expr
  { "implementation: MODULE UIDENT EQUAL WITH" }

(* implementation: MODULE UIDENT COLON WITH *)
| /module_binding_body: COLON . module_type EQUAL module_expr
  { "implementation: MODULE UIDENT COLON WITH" }

(* implementation: MODULE UIDENT LPAREN RPAREN WITH *)
| [_ /module_binding_body: functor_arg . module_binding_body]
  { "implementation: MODULE UIDENT LPAREN RPAREN WITH" }

(* implementation: EXCEPTION LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_ident: LPAREN . COLONCOLON RPAREN
  { "implementation: EXCEPTION LPAREN WITH" }

(* parse_any_longident: LBRACKET WITH *)
| /constr_extra_nonprefix_ident: LBRACKET . RBRACKET
  { "parse_any_longident: LBRACKET WITH" }

(* implementation: EXCEPTION FALSE OF WITH *)
| /generalized_constructor_arguments: OF . constructor_arguments
  { "implementation: EXCEPTION FALSE OF WITH" }

(* implementation: EXCEPTION FALSE COLON LBRACE WITH *)
| /constructor_arguments: LBRACE . label_declarations RBRACE
  { "implementation: EXCEPTION FALSE COLON LBRACE WITH" }

(* implementation: EXCEPTION FALSE COLON LBRACE MUTABLE WITH *)
| [_ /label_declaration: mutable_flag . LIDENT COLON possibly_poly(core_type_no_attr) list(attribute)
     /label_declaration_semi: mutable_flag . LIDENT COLON possibly_poly(core_type_no_attr) list(attribute) SEMI list(attribute)]
  { "implementation: EXCEPTION FALSE COLON LBRACE MUTABLE WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTE LIDENT QUOTE LIDENT WITH *)
| [_ /possibly_poly(core_type_no_attr): reversed_nonempty_llist(typevar) . DOT alias_type
     /reversed_nonempty_llist(typevar): reversed_nonempty_llist(typevar) . QUOTE ident]
  { "parse_core_type: LESS LIDENT COLON QUOTE LIDENT QUOTE LIDENT WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR WITH *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /possibly_poly(core_type_no_attr): reversed_nonempty_llist(typevar) DOT alias_type .]
  { "parse_core_type: LESS LIDENT COLON QUOTE LIDENT DOT QUOTED_STRING_EXPR WITH" }

(* parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR WITH *)
| [_ /alias_type: alias_type . AS QUOTE ident
     /possibly_poly(core_type_no_attr): alias_type .]
  { "parse_core_type: LESS LIDENT COLON QUOTED_STRING_EXPR WITH" }

(* implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR SEMI LBRACKETAT AND RBRACKET WHILE *)
| [_ /label_declarations: label_declaration_semi .
     /label_declarations: label_declaration_semi . label_declarations]
  { "implementation: EXCEPTION FALSE COLON LBRACE LIDENT COLON QUOTED_STRING_EXPR SEMI LBRACKETAT AND RBRACKET WHILE" }

(* implementation: EXCEPTION FALSE OF QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /constructor_arguments: atomic_type .
     /reversed_separated_nonempty_llist(STAR,atomic_type): atomic_type .]
  { "implementation: EXCEPTION FALSE OF QUOTED_STRING_EXPR WHILE" }

(* implementation: EXCEPTION FALSE COLON WITH *)
| /generalized_constructor_arguments: COLON . constructor_arguments MINUSGREATER atomic_type
  /generalized_constructor_arguments: COLON . atomic_type
  { "implementation: EXCEPTION FALSE COLON WITH" }

(* implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR MINUSGREATER QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /generalized_constructor_arguments: COLON constructor_arguments MINUSGREATER atomic_type .]
  { "implementation: EXCEPTION FALSE COLON QUOTED_STRING_EXPR MINUSGREATER QUOTED_STRING_EXPR WHILE" }

(* implementation: MODULE WITH *)
| /module_type_declaration: MODULE . TYPE ext list(attribute) ident option(preceded(EQUAL,module_type)) list(post_item_attribute)
  /structure_item: MODULE . ext list(attribute) module_name module_binding_body list(post_item_attribute)
  /structure_item: MODULE . ext list(attribute) REC module_name module_binding_body list(post_item_attribute) list(and_module_binding)
  { "implementation: MODULE WITH" }

(* implementation: MODULE TYPE LIDENT EQUAL WITH *)
| /option(preceded(EQUAL,module_type)): EQUAL . module_type
  { "implementation: MODULE TYPE LIDENT EQUAL WITH" }

(* implementation: MODULE TYPE LIDENT EQUAL QUOTED_STRING_EXPR WHILE *)
| [_ /module_type: module_type . attribute
     /module_type: module_type . MINUSGREATER module_type
     /module_type: module_type . WITH reversed_separated_nonempty_llist(AND,with_constraint)
     /option(preceded(EQUAL,module_type)): EQUAL module_type .]
  { "implementation: MODULE TYPE LIDENT EQUAL QUOTED_STRING_EXPR WHILE" }

(* implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND WITH *)
| /list(and_module_binding): AND . list(attribute) module_name module_binding_body list(post_item_attribute) list(and_module_binding)
  { "implementation: MODULE REC UIDENT EQUAL QUOTED_STRING_EXPR AND WITH" }

(* implementation: LBRACKETPERCENTPERCENT UNDERSCORE *)
| /item_extension: LBRACKETPERCENTPERCENT . attr_id payload RBRACKET
  { "implementation: LBRACKETPERCENTPERCENT UNDERSCORE" }

(* implementation: LBRACKETATATAT AND QUESTION WITH *)
| /payload: QUESTION . pattern
  /payload: QUESTION . pattern WHEN seq_expr
  { "implementation: LBRACKETATATAT AND QUESTION WITH" }

(* implementation: LBRACKETATATAT UNDERSCORE *)
| /floating_attribute: LBRACKETATATAT . attr_id payload RBRACKET
  { "implementation: LBRACKETATATAT UNDERSCORE" }

(* implementation: INCLUDE WITH *)
| /structure_item: INCLUDE . ext list(attribute) module_expr list(post_item_attribute)
  { "implementation: INCLUDE WITH" }

(* implementation: EXTERNAL WITH *)
| /primitive_declaration: EXTERNAL . ext list(attribute) val_ident COLON core_type EQUAL nonempty_list(raw_string) list(post_item_attribute)
  { "implementation: EXTERNAL WITH" }

(* implementation: EXTERNAL LIDENT COLON QUOTED_STRING_EXPR EQUAL STRING WITH *)
| /nonempty_list(raw_string): STRING .
  /nonempty_list(raw_string): STRING . nonempty_list(raw_string)
  { "implementation: EXTERNAL LIDENT COLON QUOTED_STRING_EXPR EQUAL STRING WITH" }

(* implementation: EXCEPTION WITH *)
| /sig_exception_declaration: EXCEPTION . ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) list(post_item_attribute)
  /str_exception_declaration: EXCEPTION . ext list(attribute) constr_ident EQUAL constr_longident list(attribute) list(post_item_attribute)
  { "implementation: EXCEPTION WITH" }

(* parse_constr_longident: LPAREN WITH *)
| /constr_extra_nonprefix_ident: LPAREN . RPAREN
  /constr_longident: LPAREN . COLONCOLON RPAREN
  { "parse_constr_longident: LPAREN WITH" }

(* parse_constr_longident: UIDENT WITH *)
| [_ /constr_longident: mod_longident .
     /constr_longident: mod_longident . DOT LPAREN COLONCOLON RPAREN
     /mk_longident(mod_longident,UIDENT): mod_longident . DOT UIDENT]
  { "parse_constr_longident: UIDENT WITH" }

(* implementation: LBRACKETATATAT AND COLON WITH *)
| /payload: COLON . signature
  /payload: COLON . core_type
  { "implementation: LBRACKETATATAT AND COLON WITH" }

(* interface: SEMISEMI WITH *)
| /list(signature_element): SEMISEMI . list(signature_element)
  { "interface: SEMISEMI WITH" }

(* interface: OPEN WITH *)
| /open_description: OPEN . ext list(attribute) mod_ext_longident list(post_item_attribute)
  /open_description: OPEN . BANG ext list(attribute) mod_ext_longident list(post_item_attribute)
  { "interface: OPEN WITH" }

(* interface: MODULE WITH *)
| /module_subst: MODULE . ext list(attribute) UIDENT COLONEQUAL mod_ext_longident list(post_item_attribute)
  /module_type_declaration: MODULE . TYPE ext list(attribute) ident option(preceded(EQUAL,module_type)) list(post_item_attribute)
  /module_type_subst: MODULE . TYPE ext list(attribute) ident COLONEQUAL module_type list(post_item_attribute)
  /signature_item: MODULE . ext list(attribute) module_name module_declaration_body list(post_item_attribute)
  /signature_item: MODULE . ext list(attribute) module_name EQUAL mod_longident list(post_item_attribute)
  /signature_item: MODULE . ext list(attribute) REC module_name COLON module_type list(post_item_attribute) list(and_module_declaration)
  { "interface: MODULE WITH" }

(* interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND WITH *)
| /list(and_module_declaration): AND . list(attribute) module_name COLON module_type list(post_item_attribute) list(and_module_declaration)
  { "interface: MODULE REC UIDENT COLON QUOTED_STRING_EXPR AND WITH" }

(* interface: MODULE UIDENT COLON WITH *)
| /module_declaration_body: COLON . module_type
  { "interface: MODULE UIDENT COLON WITH" }

(* interface: MODULE UIDENT LPAREN RPAREN WITH *)
| [_ /module_declaration_body: functor_arg . module_declaration_body]
  { "interface: MODULE UIDENT LPAREN RPAREN WITH" }

(* interface: INCLUDE WITH *)
| /signature_item: INCLUDE . ext list(attribute) module_type list(post_item_attribute)
  { "interface: INCLUDE WITH" }

(* interface: EXCEPTION WITH *)
| /sig_exception_declaration: EXCEPTION . ext list(attribute) constr_ident generalized_constructor_arguments list(attribute) list(post_item_attribute)
  { "interface: EXCEPTION WITH" }

(* interface: LBRACKETATATAT AND RBRACKET WITH *)
| [_ /list(signature_element): signature_item . list(signature_element)]
  { "interface: LBRACKETATATAT AND RBRACKET WITH" }

(* interface: QUOTED_STRING_ITEM WITH *)
| [_ /signature_item: item_extension . list(post_item_attribute)]
  { "interface: QUOTED_STRING_ITEM WITH" }

(* interface: TYPE LIDENT EQUAL FALSE HASH *)
| [_ /signature_item: generic_type_declaration(nonrec_flag,type_kind) . list(generic_and_type_declaration(type_kind))]
  { "interface: TYPE LIDENT EQUAL FALSE HASH" }

(* implementation: TYPE LIDENT AND WITH *)
| /list(generic_and_type_declaration(type_kind)): AND . list(attribute) type_parameters LIDENT type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_kind))
  { "implementation: TYPE LIDENT AND WITH" }

(* interface: TYPE LIDENT COLONEQUAL FALSE LBRACKETATAT AND RBRACKET METHOD *)
| [_ /signature_item: generic_type_declaration(no_nonrec_flag,type_subst_kind) . list(generic_and_type_declaration(type_subst_kind))]
  { "interface: TYPE LIDENT COLONEQUAL FALSE LBRACKETATAT AND RBRACKET METHOD" }

(* interface: TYPE LIDENT COLONEQUAL FALSE AND WITH *)
| /list(generic_and_type_declaration(type_subst_kind)): AND . list(attribute) type_parameters LIDENT COLONEQUAL nonempty_type_kind reversed_llist(preceded(CONSTRAINT,constrain)) list(post_item_attribute) list(generic_and_type_declaration(type_subst_kind))
  { "interface: TYPE LIDENT COLONEQUAL FALSE AND WITH" }

(* implementation: TYPE LIDENT EQUAL LBRACKET WITH *)
| /atomic_type: LBRACKET . tag_field RBRACKET
  /atomic_type: LBRACKET . BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /atomic_type: LBRACKET . row_field BAR reversed_separated_nonempty_llist(BAR,row_field) RBRACKET
  /constr_extra_nonprefix_ident: LBRACKET . RBRACKET
  { "implementation: TYPE LIDENT EQUAL LBRACKET WITH" }

(* implementation: TYPE LIDENT EQUAL LBRACE WITH *)
| /nonempty_type_kind: LBRACE . label_declarations RBRACE
  { "implementation: TYPE LIDENT EQUAL LBRACE WITH" }

(* implementation: TYPE LIDENT EQUAL BAR WITH *)
| /constructor_declarations: BAR .
  /generic_constructor_declaration(BAR): BAR . constr_ident generalized_constructor_arguments list(attribute)
  { "implementation: TYPE LIDENT EQUAL BAR WITH" }

(* implementation: TYPE LIDENT EQUAL FALSE LBRACKETAT AND RBRACKET WHILE *)
| [_ /constructor_declarations: reversed_bar_llist(constructor_declaration) .
     /reversed_bar_llist(constructor_declaration): reversed_bar_llist(constructor_declaration) . generic_constructor_declaration(BAR)]
  { "implementation: TYPE LIDENT EQUAL FALSE LBRACKETAT AND RBRACKET WHILE" }

(* interface: TYPE LIDENT PLUSEQ BAR WITH *)
| /generic_constructor_declaration(BAR): BAR . constr_ident generalized_constructor_arguments list(attribute)
  { "interface: TYPE LIDENT PLUSEQ BAR WITH" }

(* implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /nonempty_type_kind: core_type .
     /nonempty_type_kind: core_type . EQUAL constructor_declarations
     /nonempty_type_kind: core_type . EQUAL PRIVATE constructor_declarations
     /nonempty_type_kind: core_type . EQUAL DOTDOT
     /nonempty_type_kind: core_type . EQUAL PRIVATE DOTDOT
     /nonempty_type_kind: core_type . EQUAL LBRACE label_declarations RBRACE
     /nonempty_type_kind: core_type . EQUAL PRIVATE LBRACE label_declarations RBRACE]
  { "implementation: TYPE LIDENT EQUAL QUOTED_STRING_EXPR WITH" }

(* implementation: TYPE LIDENT EQUAL FALSE WITH *)
| [_ /generic_constructor_declaration(epsilon): constr_ident . generalized_constructor_arguments list(attribute)]
  { "implementation: TYPE LIDENT EQUAL FALSE WITH" }

(* implementation: LBRACKETATATAT AND COLON QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /payload: COLON core_type .]
  { "implementation: LBRACKETATATAT AND COLON QUOTED_STRING_EXPR WITH" }

(* implementation: QUOTED_STRING_ITEM WITH *)
| [_ /structure_item: item_extension . list(post_item_attribute)]
  { "implementation: QUOTED_STRING_ITEM WITH" }

(* implementation: QUOTED_STRING_ITEM LET WITH *)
| /let_bindings(ext): LET . ext list(attribute) rec_flag let_binding_body list(post_item_attribute)
  { "implementation: QUOTED_STRING_ITEM LET WITH" }

(* implementation: TYPE LIDENT LBRACKETATAT AND RBRACKET METHOD *)
| [_ /structure_item: generic_type_declaration(nonrec_flag,type_kind) . list(generic_and_type_declaration(type_kind))]
  { "implementation: TYPE LIDENT LBRACKETATAT AND RBRACKET METHOD" }

(* implementation: UIDENT TO *)
| [_ /structure: seq_expr . list(post_item_attribute) list(structure_element)]
  { "implementation: UIDENT TO" }

(* interface: INCLUDE MODULE TYPE OF QUOTED_STRING_EXPR IN *)
| [_ /module_expr: module_expr . attribute
     /module_expr: module_expr . paren_module_expr
     /module_expr: module_expr . LPAREN RPAREN
     /module_type: MODULE TYPE OF list(attribute) module_expr .]
  { "interface: INCLUDE MODULE TYPE OF QUOTED_STRING_EXPR IN" }

(* implementation: TYPE LIDENT PLUSEQ BAR WITH *)
| /extension_constructor_rebind(BAR): BAR . constr_ident EQUAL constr_longident list(attribute)
  /generic_constructor_declaration(BAR): BAR . constr_ident generalized_constructor_arguments list(attribute)
  { "implementation: TYPE LIDENT PLUSEQ BAR WITH" }

(* implementation: TYPE LIDENT PLUSEQ FALSE WITH *)
| [_ /extension_constructor_rebind(epsilon): constr_ident . EQUAL constr_longident list(attribute)
     /generic_constructor_declaration(epsilon): constr_ident . generalized_constructor_arguments list(attribute)]
  { "implementation: TYPE LIDENT PLUSEQ FALSE WITH" }

(* parse_core_type: LESS QUOTED_STRING_EXPR WHILE *)
| [_ /atomic_type: atomic_type . type_longident
     /atomic_type: atomic_type . HASH clty_longident
     /meth_list: atomic_type . SEMI meth_list
     /meth_list: atomic_type . SEMI
     /meth_list: atomic_type .]
  { "parse_core_type: LESS QUOTED_STRING_EXPR WHILE" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /reversed_separated_nontrivial_llist(COMMA,core_type): reversed_separated_nontrivial_llist(COMMA,core_type) COMMA core_type .]
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR WITH" }

(* parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /reversed_separated_nontrivial_llist(COMMA,core_type): core_type COMMA core_type .]
  { "parse_core_type: LPAREN QUOTED_STRING_EXPR COMMA QUOTED_STRING_EXPR WITH" }

(* implementation: TYPE LIDENT EQUAL PRIVATE QUOTED_STRING_EXPR WITH *)
| [_ /core_type: core_type . attribute
     /nonempty_type_kind: PRIVATE core_type .]
  { "implementation: TYPE LIDENT EQUAL PRIVATE QUOTED_STRING_EXPR WITH" }

(* implementation: SEMISEMI END *)
| [_ /implementation: structure . EOF]
  { "implementation: SEMISEMI END" }

(* interface: SEMISEMI END *)
| [_ /interface: signature . EOF]
  { "interface: SEMISEMI END" }

(* implementation: WITH *)
| /implementation': . implementation
  { "implementation: WITH" }

(* interface: WITH *)
| /interface': . interface
  { "interface: WITH" }
